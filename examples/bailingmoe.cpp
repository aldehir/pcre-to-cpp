// Auto-generated by pcre_to_cpp.py
// Do not edit manually
//
// Original PCRE pattern:
//
//   '(?i:[sdmt]|ll|ve|re)|[^\r\n\p{L}\p{N}]?+\p{L}+|\p{N}| ?[^\s\p{L}\p{N}]++[\r\n]*|\s*[\r\n]|\s+(?!\S)|\s+
//

#include "unicode.h"

#include <string>
#include <vector>
#include <cstdint>
/**
 * Split text into tokens using the 'test' pattern.
 *
 * @param text     UTF-8 encoded input string
 * @param offsets  Chunk sizes from previous tokenization pass
 * @return         New chunk sizes after applying this pattern
 */
std::vector<size_t> unicode_regex_split_test(
    const std::string & text,
    const std::vector<size_t> & offsets
) {
    std::vector<size_t> bpe_offsets;
    bpe_offsets.reserve(offsets.size());
    
    // Convert UTF-8 to codepoints for pattern matching
    const auto cpts = unicode_cpts_from_utf8(text);
    
    // Pre-allocated backtracking stack for quantifier matching
    // Uses a single vector with base-index tracking to avoid per-match allocations
    std::vector<size_t> bt_stack;
    bt_stack.reserve(cpts.size() * 2);
    
    size_t start = 0;
    
    // Process each chunk from the previous tokenization pass
    for (auto offset : offsets) {
        const size_t offset_ini = start;
        const size_t offset_end = start + offset;
        start = offset_end;
        
        // Sentinel value for out-of-bounds codepoint access
        static const uint32_t OUT_OF_RANGE = 0xFFFFFFFF;
        
        // Helper: Get codepoint at position (returns OUT_OF_RANGE if outside chunk)
        auto _get_cpt = [&](const size_t pos) -> uint32_t {
            return (offset_ini <= pos && pos < offset_end) ? cpts[pos] : OUT_OF_RANGE;
        };
        
        // Helper: Get Unicode flags for codepoint at position
        auto _get_flags = [&](const size_t pos) -> unicode_cpt_flags {
            return (offset_ini <= pos && pos < offset_end) ? unicode_cpt_flags_from_cpt(cpts[pos]) : unicode_cpt_flags{};
        };
        
        // Helper: Emit a token from _prev_end to 'end'
        size_t _prev_end = offset_ini;
        auto _add_token = [&](const size_t end) -> size_t {
            size_t len = end - _prev_end;
            if (len > 0) {
                bpe_offsets.push_back(len);
            }
            _prev_end = end;
            return len;
        };
        
        // =======================================================
        // Main matching loop
        // Try each alternative in order. First match wins.
        // On match: emit token boundary and continue from new position.
        // On no match: consume single character as fallback.
        // =======================================================
        for (size_t pos = offset_ini; pos < offset_end; ) {
            
            // Alternative: '(?i:([sdmt]|ll|ve|re))
            {
                size_t match_pos = pos;
                bool matched = true;
                if (matched && _get_cpt(match_pos) == 39) { // U+0027 '\''
                    match_pos++;
                } else if (matched) { matched = false; }
                // Case-insensitive group
                // Nested alternation
                if (matched) {
                    size_t alt_save = match_pos;
                    bool alt_matched = false;
                    // Character class: [sdmt] (case-insensitive)
                    if (matched) {
                        uint32_t cpt_1 = _get_cpt(match_pos);
                        auto flags_cpt_1 = _get_flags(match_pos);
                        // Match if any of: s | d | m | t
                        if ((unicode_tolower(cpt_1) == 115)
                            || (unicode_tolower(cpt_1) == 100)
                            || (unicode_tolower(cpt_1) == 109)
                            || (unicode_tolower(cpt_1) == 116)
                        ) {
                            match_pos++;
                        }
                        else { matched = false; }
                    }
                    if (matched) alt_matched = true;
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 108) { // U+006C 'l' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 108) { // U+006C 'l' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 118) { // U+0076 'v' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 101) { // U+0065 'e' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 114) { // U+0072 'r' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 101) { // U+0065 'e' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    matched = alt_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: [^\r\n\p{L}\p{N}]?+\p{L}+
            {
                size_t match_pos = pos;
                bool matched = true;
                // Optional match
                {
                    size_t save_pos = match_pos;
                    bool save_matched = matched;
                    // Character class: [^\r\n\p{L}\p{N}]
                    if (matched) {
                        uint32_t cpt_2 = _get_cpt(match_pos);
                        auto flags_cpt_2 = _get_flags(match_pos);
                        // Match if NOT any of: \r | \n | \p{L} | \p{N}
                        bool in_class = (cpt_2 == 13)
                            || (cpt_2 == 10)
                            || (flags_cpt_2.is_letter)
                            || (flags_cpt_2.is_number)
                        ;
                        if (!in_class && cpt_2 != OUT_OF_RANGE) {
                            match_pos++;
                        } else { matched = false; }
                    }
                    if (!matched) {
                        match_pos = save_pos;
                        matched = save_matched;
                    }
                }
                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_3 = _get_cpt(match_pos);
                            auto flags_cpt_3 = _get_flags(match_pos);
                            if (flags_cpt_3.is_letter) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \p{N}
            {
                size_t match_pos = pos;
                bool matched = true;
                if (matched) {
                    uint32_t cpt_4 = _get_cpt(match_pos);
                    auto flags_cpt_4 = _get_flags(match_pos);
                    if (flags_cpt_4.is_number) {
                        match_pos++;
                    } else { matched = false; }
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative:  ?[^\s\p{L}\p{N}]++[\r\n]*
            {
                size_t match_pos = pos;
                bool matched = true;
                // Sequence with backtracking (2 quantifiers):  ?[^\s\p{L}\p{N}]++[\r\n]*
                {
                    bool seq_matched = false;
                    size_t bt_base = bt_stack.size();  // Save stack state
                    
                    // Quantifier 0:  ?
                    size_t q0_base = bt_stack.size();
                    bt_stack.push_back(match_pos);
                    {
                        while (bt_stack.size() - q0_base <= 1) {
                            size_t save_pos = match_pos;
                            matched = true;
                            if (matched && _get_cpt(match_pos) == 32) { // U+0020 ' '
                                match_pos++;
                            } else if (matched) { matched = false; }
                            if (matched && match_pos > save_pos) {
                                bt_stack.push_back(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }
                    }
                    size_t q0_count = bt_stack.size() - q0_base;
                    
                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = bt_stack[q0_base + i0 - 1];
                        matched = true;
                        // One or more
                        {
                            size_t count = 0;
                            while (matched) {
                                size_t save_pos = match_pos;
                                // Character class: [^\s\p{L}\p{N}]
                                if (matched) {
                                    uint32_t cpt_5 = _get_cpt(match_pos);
                                    auto flags_cpt_5 = _get_flags(match_pos);
                                    // Match if NOT any of: \s | \p{L} | \p{N}
                                    bool in_class = (flags_cpt_5.is_whitespace)
                                        || (flags_cpt_5.is_letter)
                                        || (flags_cpt_5.is_number)
                                    ;
                                    if (!in_class && cpt_5 != OUT_OF_RANGE) {
                                        match_pos++;
                                    } else { matched = false; }
                                }
                                if (!matched || match_pos == save_pos) {
                                    match_pos = save_pos;
                                    matched = (count > 0);
                                    break;
                                }
                                count++;
                            }
                        }
                        if (!matched) continue;
                        
                        // Quantifier 1: [\r\n]*
                        size_t q1_base = bt_stack.size();
                        bt_stack.push_back(match_pos);
                        {
                            while (true) {
                                size_t save_pos = match_pos;
                                matched = true;
                                // Character class: [\r\n]
                                if (matched) {
                                    uint32_t cpt_6 = _get_cpt(match_pos);
                                    auto flags_cpt_6 = _get_flags(match_pos);
                                    // Match if any of: \r | \n
                                    if ((cpt_6 == 13)
                                        || (cpt_6 == 10)
                                    ) {
                                        match_pos++;
                                    }
                                    else { matched = false; }
                                }
                                if (matched && match_pos > save_pos) {
                                    bt_stack.push_back(match_pos);
                                } else {
                                    match_pos = save_pos;
                                    break;
                                }
                            }
                        }
                        size_t q1_count = bt_stack.size() - q1_base;
                        
                        // Try quantifier 1 positions longest-first (greedy, min_count=0)
                        for (size_t i1 = q1_count; i1 > 0; i1--) {
                            match_pos = bt_stack[q1_base + i1 - 1];
                            matched = true;
                            if (matched) { seq_matched = true; break; }
                        }
                        bt_stack.resize(q1_base);
                        if (seq_matched) break;
                    }
                    
                    bt_stack.resize(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \s*[\r\n]
            {
                size_t match_pos = pos;
                bool matched = true;
                // Sequence with backtracking (1 quantifiers): \s*[\r\n]
                {
                    bool seq_matched = false;
                    size_t bt_base = bt_stack.size();  // Save stack state
                    
                    // Quantifier 0: \s*
                    size_t q0_base = bt_stack.size();
                    bt_stack.push_back(match_pos);
                    {
                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;
                            if (matched) {
                                uint32_t cpt_7 = _get_cpt(match_pos);
                                auto flags_cpt_7 = _get_flags(match_pos);
                                if (flags_cpt_7.is_whitespace) {
                                    match_pos++;
                                } else { matched = false; }
                            }
                            if (matched && match_pos > save_pos) {
                                bt_stack.push_back(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }
                    }
                    size_t q0_count = bt_stack.size() - q0_base;
                    
                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = bt_stack[q0_base + i0 - 1];
                        matched = true;
                        // Character class: [\r\n]
                        if (matched) {
                            uint32_t cpt_8 = _get_cpt(match_pos);
                            auto flags_cpt_8 = _get_flags(match_pos);
                            // Match if any of: \r | \n
                            if ((cpt_8 == 13)
                                || (cpt_8 == 10)
                            ) {
                                match_pos++;
                            }
                            else { matched = false; }
                        }
                        if (!matched) continue;
                        
                        if (matched) { seq_matched = true; break; }
                    }
                    
                    bt_stack.resize(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \s+(?!\S)
            {
                size_t match_pos = pos;
                bool matched = true;
                // Sequence with backtracking (1 quantifiers): \s+(?!\S)
                {
                    bool seq_matched = false;
                    size_t bt_base = bt_stack.size();  // Save stack state
                    
                    // Quantifier 0: \s+
                    size_t q0_base = bt_stack.size();
                    bt_stack.push_back(match_pos);
                    {
                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;
                            if (matched) {
                                uint32_t cpt_9 = _get_cpt(match_pos);
                                auto flags_cpt_9 = _get_flags(match_pos);
                                if (flags_cpt_9.is_whitespace) {
                                    match_pos++;
                                } else { matched = false; }
                            }
                            if (matched && match_pos > save_pos) {
                                bt_stack.push_back(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }
                    }
                    size_t q0_count = bt_stack.size() - q0_base;
                    
                    // Try quantifier 0 positions longest-first (greedy, min_count=1)
                    for (size_t i0 = q0_count; i0 > 1; i0--) {
                        match_pos = bt_stack[q0_base + i0 - 1];
                        matched = true;
                        // Negative lookahead
                        {
                            size_t save_match_pos = match_pos;
                            bool save_matched = matched;
                            if (matched) {
                                uint32_t cpt_10 = _get_cpt(match_pos);
                                auto flags_cpt_10 = _get_flags(match_pos);
                                if ((!flags_cpt_10.is_whitespace && flags_cpt_10.as_uint())) {
                                    match_pos++;
                                } else { matched = false; }
                            }
                            bool lookahead_success = matched;
                            match_pos = save_match_pos;
                            matched = save_matched && !lookahead_success;
                        }
                        if (!matched) continue;
                        
                        if (matched) { seq_matched = true; break; }
                    }
                    
                    bt_stack.resize(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \s+
            {
                size_t match_pos = pos;
                bool matched = true;
                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_11 = _get_cpt(match_pos);
                            auto flags_cpt_11 = _get_flags(match_pos);
                            if (flags_cpt_11.is_whitespace) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // No alternative matched - emit single character as token
            _add_token(++pos);
        }
    }
    
    return bpe_offsets;
}