// Auto-generated by pcre_to_cpp.py
// Do not edit manually
//
// Original PCRE pattern:
//
//   's|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)
//

#include "unicode.h"

#include <string>
#include <vector>
#include <cstdint>

/**
 * Split text into tokens using the 'test' pattern.
 *
 * @param text     UTF-8 encoded input string
 * @param offsets  Chunk sizes from previous tokenization pass
 * @return         New chunk sizes after applying this pattern
 */
std::vector<size_t> unicode_regex_split_test(
    const std::string & text,
    const std::vector<size_t> & offsets
) {
    std::vector<size_t> bpe_offsets;
    bpe_offsets.reserve(offsets.size());

    // Convert UTF-8 to codepoints for pattern matching
    const auto cpts = unicode_cpts_from_utf8(text);

    // Pre-allocated backtracking stack for quantifier matching
    // Uses a single vector with base-index tracking to avoid per-match allocations
    std::vector<size_t> stack;
    stack.reserve(cpts.size() * 2);

    size_t start = 0;

    // Process each chunk from the previous tokenization pass
    for (auto offset : offsets) {
        const size_t offset_ini = start;
        const size_t offset_end = start + offset;
        start = offset_end;

        // Sentinel value for out-of-bounds codepoint access
        static const uint32_t OUT_OF_RANGE = 0xFFFFFFFF;

        // Helper: Get codepoint at position (returns OUT_OF_RANGE if outside chunk)
        auto _get_cpt = [&](const size_t pos) -> uint32_t {
            return (offset_ini <= pos && pos < offset_end) ? cpts[pos] : OUT_OF_RANGE;
        };

        // Helper: Get Unicode flags for codepoint at position
        auto _get_flags = [&](const size_t pos) -> unicode_cpt_flags {
            return (offset_ini <= pos && pos < offset_end) ? unicode_cpt_flags_from_cpt(cpts[pos]) : unicode_cpt_flags{};
        };

        // Helper: Emit a token from _prev_end to 'end'
        size_t _prev_end = offset_ini;
        auto _add_token = [&](const size_t end) -> size_t {
            size_t len = end - _prev_end;
            if (len > 0) {
                bpe_offsets.push_back(len);
            }
            _prev_end = end;
            return len;
        };

        // Helper: Try to match at current position using predicate
        // Returns true and advances mpos if condition is met
        auto _try_match = [&](size_t& mpos, bool& mflag, auto condition) -> bool {
            if (!mflag) return false;
            if (condition()) {
                mpos++;
                return true;
            }
            mflag = false;
            return false;
        };

        // Stack helpers for backtracking
        auto _stack_mark = [&]() -> size_t { return stack.size(); };
        auto _stack_push = [&](size_t p) { stack.push_back(p); };
        auto _stack_count = [&](size_t base) -> size_t { return stack.size() - base; };
        auto _stack_get = [&](size_t base, size_t idx) -> size_t { return stack[base + idx - 1]; };
        auto _stack_restore = [&](size_t base) { stack.resize(base); };

        // =======================================================
        // Main matching loop
        // Try each alternative in order. First match wins.
        // On match: emit token boundary and continue from new position.
        // On no match: consume single character as fallback.
        // =======================================================
        for (size_t pos = offset_ini; pos < offset_end; ) {

            // Alternative: 's
            {
                size_t match_pos = pos;
                bool matched = true;

                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 115; }); // U+0073 's'

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: 't
            {
                size_t match_pos = pos;
                bool matched = true;

                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 116; }); // U+0074 't'

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: 're
            {
                size_t match_pos = pos;
                bool matched = true;

                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 114; }); // U+0072 'r'
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 101; }); // U+0065 'e'

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: 've
            {
                size_t match_pos = pos;
                bool matched = true;

                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 118; }); // U+0076 'v'
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 101; }); // U+0065 'e'

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: 'm
            {
                size_t match_pos = pos;
                bool matched = true;

                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 109; }); // U+006D 'm'

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: 'll
            {
                size_t match_pos = pos;
                bool matched = true;

                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 108; }); // U+006C 'l'
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 108; }); // U+006C 'l'

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: 'd
            {
                size_t match_pos = pos;
                bool matched = true;

                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 100; }); // U+0064 'd'

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative:  ?\p{L}+
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (2 quantifiers):  ?\p{L}+
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0:  ?")
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;

                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 32; }); // U+0020 ' '

                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: \p{L}+")
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_letter; }); // \p{L}

                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            if (matched) { seq_matched = true; break; }
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative:  ?\p{N}+
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (2 quantifiers):  ?\p{N}+
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0:  ?")
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;

                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 32; }); // U+0020 ' '

                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: \p{N}+")
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_number; }); // \p{N}

                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            if (matched) { seq_matched = true; break; }
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative:  ?[^\s\p{L}\p{N}]+
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (2 quantifiers):  ?[^\s\p{L}\p{N}]+
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0:  ?")
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;

                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 32; }); // U+0020 ' '

                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: [^\s\p{L}\p{N}]+")
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            // [^\s\p{L}\p{N}]
                            _try_match(match_pos, matched, [&]{
                                uint32_t c = _get_cpt(match_pos);
                                auto f = _get_flags(match_pos);
                                return c != OUT_OF_RANGE && !(f.is_whitespace || f.is_letter || f.is_number);
                            });

                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            if (matched) { seq_matched = true; break; }
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \s+(?!\S)
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (1 quantifiers): \s+(?!\S)
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: \s+")
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (true) {
                        size_t save_pos = match_pos;
                        matched = true;

                        _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_whitespace; }); // \s

                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=1)
                    for (size_t i0 = q0_count; i0 > 1; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;
                        // Negative lookahead
                        {

                            size_t save_match_pos = match_pos;
                            bool save_matched = matched;
                            _try_match(match_pos, matched, [&]{ return (!_get_flags(match_pos).is_whitespace && _get_flags(match_pos).as_uint()); }); // \S
                            bool lookahead_success = matched;
                            match_pos = save_match_pos;
                            matched = save_matched && !lookahead_success;
                        }
                        if (!matched) continue;

                        if (matched) { seq_matched = true; break; }
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }

                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // No alternative matched - emit single character as token
            _add_token(++pos);
        }
    }

    return bpe_offsets;
}
