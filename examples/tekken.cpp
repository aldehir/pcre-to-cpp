// Auto-generated by pcre_to_cpp.py
// Do not edit manually
//
// Original PCRE pattern:
//
//   [^\r\n\p{L}\p{N}]?[\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]*[\p{Ll}\p{Lm}\p{Lo}\p{M}]+|[^\r\n\p{L}\p{N}]?[\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]+[\p{Ll}\p{Lm}\p{Lo}\p{M}]*|\p{N}| ?[^\s\p{L}\p{N}]+[\r\n/]*|\s*[\r\n]+|\s+(?!\S)|\s+
//
#include "unicode.h"

#include <string>
#include <vector>
#include <cstdint>

// Macro for match attempts
#define TRY_MATCH(cond) do {\
    if (matched) { \
        if (cond) { match_pos++; } \
        else { matched = false; } \
    } } while (0)

/**
 * Split text into tokens using the 'tekken' pattern.
 *
 * @param text     UTF-8 encoded input string
 * @param offsets  Chunk sizes from previous tokenization pass
 * @return         New chunk sizes after applying this pattern
 */
std::vector<size_t> unicode_regex_split_tekken(
    const std::string & text,
    const std::vector<size_t> & offsets
) {
    std::vector<size_t> bpe_offsets;
    bpe_offsets.reserve(offsets.size());

    // Convert UTF-8 to codepoints and pre-compute flags for pattern matching
    const auto cpts = unicode_cpts_from_utf8(text);
    const size_t n_cpts = cpts.size();
    std::vector<unicode_cpt_flags> cpt_flags(n_cpts);
    for (size_t i = 0; i < n_cpts; i++) {
        cpt_flags[i] = unicode_cpt_flags_from_cpt(cpts[i]);
    }

    // Pre-allocated backtracking stack for quantifier matching
    // Uses a single vector with base-index tracking to avoid per-match allocations
    std::vector<size_t> stack;
    stack.reserve(cpts.size() * 2);

    size_t start = 0;

    // Process each chunk from the previous tokenization pass
    for (auto offset : offsets) {
        const size_t offset_ini = start;
        const size_t offset_end = start + offset;
        start = offset_end;

        // Sentinel value for out-of-bounds codepoint access
        static const uint32_t OUT_OF_RANGE = 0xFFFFFFFF;

        // Helper: Get codepoint at position (returns OUT_OF_RANGE if outside chunk)
        auto _get_cpt = [&](const size_t pos) -> uint32_t {
            return (pos < offset_end) ? cpts[pos] : OUT_OF_RANGE;
        };

        // Helper: Get Unicode flags for codepoint at position (pre-computed)
        auto _get_flags = [&](const size_t pos) -> unicode_cpt_flags {
            return (pos < offset_end) ? cpt_flags[pos] : unicode_cpt_flags{};
        };

        // Helper: Emit a token from _prev_end to 'end'
        size_t _prev_end = offset_ini;
        auto _add_token = [&](const size_t end) -> size_t {
            size_t len = end - _prev_end;
            if (len > 0) {
                bpe_offsets.push_back(len);
            }
            _prev_end = end;
            return len;
        };

        // Stack helpers for backtracking
        auto _stack_mark = [&]() -> size_t { return stack.size(); };
        auto _stack_push = [&](size_t p) { stack.push_back(p); };
        auto _stack_count = [&](size_t base) -> size_t { return stack.size() - base; };
        auto _stack_get = [&](size_t base, size_t idx) -> size_t { return stack[base + idx - 1]; };
        auto _stack_restore = [&](size_t base) { stack.resize(base); };

        // Try each alternative in order. First match wins.
        // On match: emit token boundary and continue from new position.
        // On no match: consume single character as fallback.
        for (size_t pos = offset_ini; pos < offset_end; ) {

            // Alternative: [^\r\n\p{L}\p{N}]?[\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]*[\p{Ll}\p{Lm}\p{Lo}\p{M}]+
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (3 quantifiers): [^\r\n\p{L}\p{N}]?[\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]*[\p{Ll}\p{Lm}\p{Lo}\p{M}]+
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: [^\r\n\p{L}\p{N}]?
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;

                        // [^\r\n\p{L}\p{N}]
                        if (matched) {
                            uint32_t c = _get_cpt(match_pos);
                            auto f = _get_flags(match_pos);
                            matched = (c != OUT_OF_RANGE && !(c == 13 || c == 10 || f.is_letter || f.is_number));
                            if (matched) { match_pos++; }
                        }
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: [\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]*
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            // [\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]
                            if (matched) {
                                auto f = _get_flags(match_pos);
                                matched = ((f.is_letter && f.is_uppercase) || (f.is_letter && !f.is_uppercase && !f.is_lowercase) || f.is_accent_mark);
                                if (matched) { match_pos++; }
                            }
                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=0)
                        for (size_t i1 = q1_count; i1 > 0; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            // Quantifier 2: [\p{Ll}\p{Lm}\p{Lo}\p{M}]+ (terminal)
                            size_t q2_base = _stack_mark();

                            // One or more
                            {
                                size_t count = 0;
                                while (matched) {
                                    size_t save_pos = match_pos;

                                    // [\p{Ll}\p{Lm}\p{Lo}\p{M}]
                                    if (matched) {
                                        auto f = _get_flags(match_pos);
                                        matched = ((f.is_letter && f.is_lowercase) || (f.is_letter && !f.is_uppercase && !f.is_lowercase) || f.is_accent_mark);
                                        if (matched) { match_pos++; }
                                    }
                                    if (!matched || match_pos == save_pos) {
                                        match_pos = save_pos;
                                        matched = (count >= 1);
                                        break;
                                    }
                                    count++;
                                }
                            }
                            if (matched) { seq_matched = true; }

                            _stack_restore(q2_base);
                            if (seq_matched) break;
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: [^\r\n\p{L}\p{N}]?[\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]+[\p{Ll}\p{Lm}\p{Lo}\p{M}]*
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (3 quantifiers): [^\r\n\p{L}\p{N}]?[\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]+[\p{Ll}\p{Lm}\p{Lo}\p{M}]*
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: [^\r\n\p{L}\p{N}]?
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;

                        // [^\r\n\p{L}\p{N}]
                        if (matched) {
                            uint32_t c = _get_cpt(match_pos);
                            auto f = _get_flags(match_pos);
                            matched = (c != OUT_OF_RANGE && !(c == 13 || c == 10 || f.is_letter || f.is_number));
                            if (matched) { match_pos++; }
                        }
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: [\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]+
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            // [\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{M}]
                            if (matched) {
                                auto f = _get_flags(match_pos);
                                matched = ((f.is_letter && f.is_uppercase) || (f.is_letter && !f.is_uppercase && !f.is_lowercase) || f.is_accent_mark);
                                if (matched) { match_pos++; }
                            }
                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            // Quantifier 2: [\p{Ll}\p{Lm}\p{Lo}\p{M}]* (terminal)
                            size_t q2_base = _stack_mark();

                            // Zero or more
                            {
                                size_t count = 0;
                                while (matched) {
                                    size_t save_pos = match_pos;

                                    // [\p{Ll}\p{Lm}\p{Lo}\p{M}]
                                    if (matched) {
                                        auto f = _get_flags(match_pos);
                                        matched = ((f.is_letter && f.is_lowercase) || (f.is_letter && !f.is_uppercase && !f.is_lowercase) || f.is_accent_mark);
                                        if (matched) { match_pos++; }
                                    }
                                    if (!matched || match_pos == save_pos) {
                                        match_pos = save_pos;
                                        matched = true;
                                        break;
                                    }
                                    count++;
                                }
                            }
                            if (matched) { seq_matched = true; }

                            _stack_restore(q2_base);
                            if (seq_matched) break;
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \p{N}
            {
                size_t match_pos = pos;
                bool matched = true;
                TRY_MATCH(_get_flags(match_pos).is_number); // \p{N}
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative:  ?[^\s\p{L}\p{N}]+[\r\n/]*
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (3 quantifiers):  ?[^\s\p{L}\p{N}]+[\r\n/]*
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0:  ?
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;
                        TRY_MATCH(_get_cpt(match_pos) == 32); // U+0020 ' '
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: [^\s\p{L}\p{N}]+
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            // [^\s\p{L}\p{N}]
                            if (matched) {
                                uint32_t c = _get_cpt(match_pos);
                                auto f = _get_flags(match_pos);
                                matched = (c != OUT_OF_RANGE && !(f.is_whitespace || f.is_letter || f.is_number));
                                if (matched) { match_pos++; }
                            }
                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            // Quantifier 2: [\r\n/]* (terminal)
                            size_t q2_base = _stack_mark();

                            // Zero or more
                            {
                                size_t count = 0;
                                while (matched) {
                                    size_t save_pos = match_pos;

                                    // [\r\n/]
                                    if (matched) {
                                        uint32_t c = _get_cpt(match_pos);
                                        matched = (c == 13 || c == 10 || c == 47);
                                        if (matched) { match_pos++; }
                                    }
                                    if (!matched || match_pos == save_pos) {
                                        match_pos = save_pos;
                                        matched = true;
                                        break;
                                    }
                                    count++;
                                }
                            }
                            if (matched) { seq_matched = true; }

                            _stack_restore(q2_base);
                            if (seq_matched) break;
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \s*[\r\n]+
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (2 quantifiers): \s*[\r\n]+
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: \s*
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (true) {
                        size_t save_pos = match_pos;
                        matched = true;
                        TRY_MATCH(_get_flags(match_pos).is_whitespace); // \s
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;
                        // Quantifier 1: [\r\n]+ (terminal)
                        size_t q1_base = _stack_mark();

                        // One or more
                        {
                            size_t count = 0;
                            while (matched) {
                                size_t save_pos = match_pos;

                                // [\r\n]
                                if (matched) {
                                    uint32_t c = _get_cpt(match_pos);
                                    matched = (c == 13 || c == 10);
                                    if (matched) { match_pos++; }
                                }
                                if (!matched || match_pos == save_pos) {
                                    match_pos = save_pos;
                                    matched = (count >= 1);
                                    break;
                                }
                                count++;
                            }
                        }
                        if (matched) { seq_matched = true; }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \s+(?!\S)
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (1 quantifiers): \s+(?!\S)
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: \s+
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (true) {
                        size_t save_pos = match_pos;
                        matched = true;
                        TRY_MATCH(_get_flags(match_pos).is_whitespace); // \s
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=1)
                    for (size_t i0 = q0_count; i0 > 1; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Negative lookahead
                        {
                            size_t save_match_pos = match_pos;
                            bool save_matched = matched;
                            TRY_MATCH((!_get_flags(match_pos).is_whitespace && _get_flags(match_pos).as_uint())); // \S
                            bool lookahead_success = matched;
                            match_pos = save_match_pos;
                            matched = save_matched && !lookahead_success;
                        }
                        if (!matched) continue;

                        seq_matched = true; break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \s+
            {
                size_t match_pos = pos;
                bool matched = true;

                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        TRY_MATCH(_get_flags(match_pos).is_whitespace); // \s
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count >= 1);
                            break;
                        }
                        count++;
                    }
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // No alternative matched - emit single character as token
            _add_token(++pos);
        }
    }
    return bpe_offsets;
}