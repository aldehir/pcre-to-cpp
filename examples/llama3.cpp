// Auto-generated by pcre_to_cpp.py
// Do not edit manually
//
// Original PCRE pattern:
//
//   (?i:'s|'t|'re|'ve|'m|'ll|'d)|[^\r\n\p{L}\p{N}]?\p{L}+|\p{N}{1,3}| ?[^\s\p{L}\p{N}]+[\r\n]*|\s*[\r\n]+|\s+(?!\S)|\s+
//

#include "unicode.h"

#include <string>
#include <vector>
#include <cstdint>

/**
 * Split text into tokens using the 'test' pattern.
 *
 * @param text     UTF-8 encoded input string
 * @param offsets  Chunk sizes from previous tokenization pass
 * @return         New chunk sizes after applying this pattern
 */
std::vector<size_t> unicode_regex_split_test(
    const std::string & text,
    const std::vector<size_t> & offsets
) {
    std::vector<size_t> bpe_offsets;
    bpe_offsets.reserve(offsets.size());

    // Convert UTF-8 to codepoints for pattern matching
    const auto cpts = unicode_cpts_from_utf8(text);

    // Pre-allocated backtracking stack for quantifier matching
    // Uses a single vector with base-index tracking to avoid per-match allocations
    std::vector<size_t> stack;
    stack.reserve(cpts.size() * 2);

    size_t start = 0;

    // Process each chunk from the previous tokenization pass
    for (auto offset : offsets) {
        const size_t offset_ini = start;
        const size_t offset_end = start + offset;
        start = offset_end;

        // Sentinel value for out-of-bounds codepoint access
        static const uint32_t OUT_OF_RANGE = 0xFFFFFFFF;

        // Helper: Get codepoint at position (returns OUT_OF_RANGE if outside chunk)
        auto _get_cpt = [&](const size_t pos) -> uint32_t {
            return (offset_ini <= pos && pos < offset_end) ? cpts[pos] : OUT_OF_RANGE;
        };

        // Helper: Get Unicode flags for codepoint at position
        auto _get_flags = [&](const size_t pos) -> unicode_cpt_flags {
            return (offset_ini <= pos && pos < offset_end) ? unicode_cpt_flags_from_cpt(cpts[pos]) : unicode_cpt_flags{};
        };

        // Helper: Emit a token from _prev_end to 'end'
        size_t _prev_end = offset_ini;
        auto _add_token = [&](const size_t end) -> size_t {
            size_t len = end - _prev_end;
            if (len > 0) {
                bpe_offsets.push_back(len);
            }
            _prev_end = end;
            return len;
        };

        // Helper: Try to match at current position using predicate
        // Returns true and advances mpos if condition is met
        auto _try_match = [&](size_t& mpos, bool& mflag, auto condition) -> bool {
            if (!mflag) return false;
            if (condition()) {
                mpos++;
                return true;
            }
            mflag = false;
            return false;
        };

        // Stack helpers for backtracking
        auto _stack_mark = [&]() -> size_t { return stack.size(); };
        auto _stack_push = [&](size_t p) { stack.push_back(p); };
        auto _stack_count = [&](size_t base) -> size_t { return stack.size() - base; };
        auto _stack_get = [&](size_t base, size_t idx) -> size_t { return stack[base + idx - 1]; };
        auto _stack_restore = [&](size_t base) { stack.resize(base); };

        // =======================================================
        // Main matching loop
        // Try each alternative in order. First match wins.
        // On match: emit token boundary and continue from new position.
        // On no match: consume single character as fallback.
        // =======================================================
        for (size_t pos = offset_ini; pos < offset_end; ) {

            // Alternative: (?i:'s|'t|'re|'ve|'m|'ll|'d)
            {
                size_t match_pos = pos;
                bool matched = true;

                // Case-insensitive group

                // Nested alternation
                if (matched) {
                    size_t alt_save = match_pos;
                    bool alt_matched = false;
                    _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                    _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 115; }); // U+0073 's' (case-insensitive)

                    alt_matched |= matched;

                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 116; }); // U+0074 't' (case-insensitive)

                        alt_matched |= matched;
                    }

                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 114; }); // U+0072 'r' (case-insensitive)
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 101; }); // U+0065 'e' (case-insensitive)

                        alt_matched |= matched;
                    }

                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 118; }); // U+0076 'v' (case-insensitive)
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 101; }); // U+0065 'e' (case-insensitive)

                        alt_matched |= matched;
                    }

                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 109; }); // U+006D 'm' (case-insensitive)

                        alt_matched |= matched;
                    }

                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 108; }); // U+006C 'l' (case-insensitive)
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 108; }); // U+006C 'l' (case-insensitive)

                        alt_matched |= matched;
                    }

                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 39; }); // U+0027 '\''
                        _try_match(match_pos, matched, [&]{ return unicode_tolower(_get_cpt(match_pos)) == 100; }); // U+0064 'd' (case-insensitive)

                        alt_matched |= matched;
                    }

                    matched = alt_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: [^\r\n\p{L}\p{N}]?\p{L}+
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (2 quantifiers): [^\r\n\p{L}\p{N}]?\p{L}+
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: [^\r\n\p{L}\p{N}]?
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;

                        // [^\r\n\p{L}\p{N}]
                        _try_match(match_pos, matched, [&]{
                            uint32_t c = _get_cpt(match_pos);
                            auto f = _get_flags(match_pos);
                            return c != OUT_OF_RANGE && !(c == 13 || c == 10 || f.is_letter || f.is_number);
                        });
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: \p{L}+
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;
                            _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_letter; }); // \p{L}
                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            if (matched) { seq_matched = true; break; }
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \p{N}{1,3}
            {
                size_t match_pos = pos;
                bool matched = true;

                // 1 to 3 matches
                {
                    size_t count = 0;
                    while (matched && count < 3) {
                        size_t save_pos = match_pos;
                        _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_number; }); // \p{N}
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count >= 1);
                            break;
                        }
                        count++;
                    }
                    if (count < 1) matched = false;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative:  ?[^\s\p{L}\p{N}]+[\r\n]*
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (3 quantifiers):  ?[^\s\p{L}\p{N}]+[\r\n]*
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0:  ?
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (_stack_count(q0_base) <= 1) {
                        size_t save_pos = match_pos;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_cpt(match_pos) == 32; }); // U+0020 ' '
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: [^\s\p{L}\p{N}]+
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            // [^\s\p{L}\p{N}]
                            _try_match(match_pos, matched, [&]{
                                uint32_t c = _get_cpt(match_pos);
                                auto f = _get_flags(match_pos);
                                return c != OUT_OF_RANGE && !(f.is_whitespace || f.is_letter || f.is_number);
                            });
                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;

                            // Quantifier 2: [\r\n]*
                            size_t q2_base = _stack_mark();
                            _stack_push(match_pos);

                            while (true) {
                                size_t save_pos = match_pos;
                                matched = true;

                                // [\r\n]
                                _try_match(match_pos, matched, [&]{
                                    uint32_t c = _get_cpt(match_pos);
                                    return c == 13 || c == 10;
                                });
                                if (matched && match_pos > save_pos) {
                                    _stack_push(match_pos);
                                } else {
                                    match_pos = save_pos;
                                    break;
                                }
                            }

                            size_t q2_count = _stack_count(q2_base);

                            // Try quantifier 2 positions longest-first (greedy, min_count=0)
                            for (size_t i2 = q2_count; i2 > 0; i2--) {
                                match_pos = _stack_get(q2_base, i2);
                                matched = true;
                                if (matched) { seq_matched = true; break; }
                            }

                            _stack_restore(q2_base);
                            if (seq_matched) break;
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \s*[\r\n]+
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (2 quantifiers): \s*[\r\n]+
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: \s*
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (true) {
                        size_t save_pos = match_pos;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_whitespace; }); // \s
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=0)
                    for (size_t i0 = q0_count; i0 > 0; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Quantifier 1: [\r\n]+
                        size_t q1_base = _stack_mark();
                        _stack_push(match_pos);

                        while (true) {
                            size_t save_pos = match_pos;
                            matched = true;

                            // [\r\n]
                            _try_match(match_pos, matched, [&]{
                                uint32_t c = _get_cpt(match_pos);
                                return c == 13 || c == 10;
                            });
                            if (matched && match_pos > save_pos) {
                                _stack_push(match_pos);
                            } else {
                                match_pos = save_pos;
                                break;
                            }
                        }

                        size_t q1_count = _stack_count(q1_base);

                        // Try quantifier 1 positions longest-first (greedy, min_count=1)
                        for (size_t i1 = q1_count; i1 > 1; i1--) {
                            match_pos = _stack_get(q1_base, i1);
                            matched = true;
                            if (matched) { seq_matched = true; break; }
                        }

                        _stack_restore(q1_base);
                        if (seq_matched) break;
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \s+(?!\S)
            {
                size_t match_pos = pos;
                bool matched = true;

                // Sequence with backtracking (1 quantifiers): \s+(?!\S)
                {
                    bool seq_matched = false;
                    size_t bt_base = _stack_mark();  // Save stack state

                    // Quantifier 0: \s+
                    size_t q0_base = _stack_mark();
                    _stack_push(match_pos);

                    while (true) {
                        size_t save_pos = match_pos;
                        matched = true;
                        _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_whitespace; }); // \s
                        if (matched && match_pos > save_pos) {
                            _stack_push(match_pos);
                        } else {
                            match_pos = save_pos;
                            break;
                        }
                    }

                    size_t q0_count = _stack_count(q0_base);

                    // Try quantifier 0 positions longest-first (greedy, min_count=1)
                    for (size_t i0 = q0_count; i0 > 1; i0--) {
                        match_pos = _stack_get(q0_base, i0);
                        matched = true;

                        // Negative lookahead
                        {
                            size_t save_match_pos = match_pos;
                            bool save_matched = matched;
                            _try_match(match_pos, matched, [&]{ return (!_get_flags(match_pos).is_whitespace && _get_flags(match_pos).as_uint()); }); // \S
                            bool lookahead_success = matched;
                            match_pos = save_match_pos;
                            matched = save_matched && !lookahead_success;
                        }
                        if (!matched) continue;

                        if (matched) { seq_matched = true; break; }
                    }

                    _stack_restore(bt_base);  // Restore stack state
                    matched = seq_matched;
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // Alternative: \s+
            {
                size_t match_pos = pos;
                bool matched = true;

                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        _try_match(match_pos, matched, [&]{ return _get_flags(match_pos).is_whitespace; }); // \s
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }

            // No alternative matched - emit single character as token
            _add_token(++pos);
        }
    }
    return bpe_offsets;
}