// Benchmark harness for PCRE-to-C++ vs STL regex comparison
// Reads JSON input from stdin, benchmarks both implementations, outputs results

#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <chrono>
#include <sstream>
#include <iomanip>
#include <memory>

#include "nlohmann/json.hpp"
#include "unicode.h"

using json = nlohmann::json;

// Fixed number of iterations for benchmarking
constexpr int BENCHMARK_ITERATIONS = 20;

// Forward declaration - this function is generated by pcre_to_cpp.py --name test
std::vector<size_t> unicode_regex_split_test(
    const std::string & text,
    const std::vector<size_t> & offsets
);

// Convert offset list to token strings
std::vector<std::string> offsets_to_tokens(const std::string & text, const std::vector<size_t> & offsets) {
    std::vector<std::string> tokens;
    auto cpts = unicode_cpts_from_utf8(text);

    size_t pos = 0;
    for (size_t offset : offsets) {
        std::string token;
        for (size_t i = 0; i < offset && pos + i < cpts.size(); i++) {
            token += unicode_cpt_to_utf8(cpts[pos + i]);
        }
        tokens.push_back(token);
        pos += offset;
    }

    return tokens;
}

// STL regex result structure
struct StlRegexResult {
    std::vector<std::string> tokens;
    bool success;
    std::string error;
};

// Run STL regex with precompiled regex
StlRegexResult run_stl_regex(const std::regex & re, const std::string & text) {
    StlRegexResult result;
    result.success = true;

    try {
        std::sregex_iterator iter(text.begin(), text.end(), re);
        std::sregex_iterator end;

        while (iter != end) {
            result.tokens.push_back(iter->str());
            ++iter;
        }
    }
    catch (const std::regex_error & e) {
        result.success = false;
        result.error = std::string("regex_error: ") + e.what();
        result.tokens.clear();
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = std::string("exception: ") + e.what();
        result.tokens.clear();
    }

    return result;
}

// Try to compile STL regex, returns nullptr on failure
struct StlRegexCompileResult {
    std::unique_ptr<std::regex> regex;
    bool success;
    std::string error;
};

StlRegexCompileResult compile_stl_regex(const std::string & pattern) {
    StlRegexCompileResult result;
    result.success = true;

    try {
        result.regex = std::make_unique<std::regex>(pattern, std::regex::ECMAScript | std::regex::nosubs | std::regex::optimize);
    }
    catch (const std::regex_error & e) {
        result.success = false;
        result.error = std::string("regex_error: ") + e.what();
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = std::string("exception: ") + e.what();
    }

    return result;
}

// Benchmark result structure
struct BenchmarkResult {
    std::string input;
    double generated_time_ms;
    double stl_time_ms;
    std::vector<std::string> generated_tokens;
    std::vector<std::string> stl_tokens;
    bool stl_success;
    std::string stl_error;
    double speedup;
};

// Benchmark a single string with precompiled STL regex (can be nullptr if compilation failed)
BenchmarkResult benchmark_string(const std::regex * stl_regex, const std::string & stl_error,
                                  const std::string & text) {
    BenchmarkResult result;
    result.input = text;

    // Benchmark generated code
    {
        auto cpts = unicode_cpts_from_utf8(text);
        std::vector<size_t> initial_offsets = { cpts.size() };

        // Warmup run
        auto warmup_offsets = unicode_regex_split_test(text, initial_offsets);
        result.generated_tokens = offsets_to_tokens(text, warmup_offsets);

        // Timed runs
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {
            auto offsets = unicode_regex_split_test(text, initial_offsets);
            (void)offsets; // Prevent optimization
        }
        auto end = std::chrono::high_resolution_clock::now();
        result.generated_time_ms = std::chrono::duration<double, std::milli>(end - start).count();
    }

    // Benchmark STL regex (precompiled)
    {
        if (stl_regex) {
            // Warmup run
            auto warmup_result = run_stl_regex(*stl_regex, text);
            result.stl_tokens = warmup_result.tokens;
            result.stl_success = warmup_result.success;
            result.stl_error = warmup_result.error;

            if (result.stl_success) {
                // Timed runs with precompiled regex
                auto start = std::chrono::high_resolution_clock::now();
                for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {
                    try {
                        std::sregex_iterator iter(text.begin(), text.end(), *stl_regex);
                        std::sregex_iterator end;
                        while (iter != end) {
                            ++iter;
                        }
                    }
                    catch (...) {
                        // Count as failure during benchmark
                        result.stl_success = false;
                        result.stl_error = "exception during benchmark iterations";
                        break;
                    }
                }
                auto end = std::chrono::high_resolution_clock::now();
                result.stl_time_ms = std::chrono::duration<double, std::milli>(end - start).count();
            } else {
                result.stl_time_ms = 0.0;
            }
        } else {
            // Regex compilation failed
            result.stl_success = false;
            result.stl_error = stl_error;
            result.stl_time_ms = 0.0;
        }
    }

    // Calculate speedup
    if (result.stl_success && result.stl_time_ms > 0) {
        result.speedup = result.stl_time_ms / result.generated_time_ms;
    } else {
        result.speedup = 0.0;
    }

    return result;
}

// Escape string for display (truncate if too long)
std::string escape_for_display(const std::string & s, size_t max_len = 40) {
    std::string result;
    for (char c : s) {
        if (result.size() >= max_len) {
            result += "...";
            break;
        }
        if (c == '\n') result += "\\n";
        else if (c == '\r') result += "\\r";
        else if (c == '\t') result += "\\t";
        else if (c == '"') result += "\\\"";
        else result += c;
    }
    return result;
}

int main() {
    try {
        // Read all input from stdin
        std::stringstream buffer;
        buffer << std::cin.rdbuf();
        std::string input = buffer.str();

        // Parse input JSON
        json input_json = json::parse(input);
        std::string pattern = input_json["pretokenizer"].get<std::string>();
        std::vector<std::string> test_strings = input_json["strings"].get<std::vector<std::string>>();

        // Precompile STL regex once
        auto stl_compile_result = compile_stl_regex(pattern);
        std::regex * stl_regex_ptr = stl_compile_result.regex.get();
        std::string stl_compile_error = stl_compile_result.error;

        // Run benchmarks
        std::vector<BenchmarkResult> results;
        double total_generated_ms = 0.0;
        double total_stl_ms = 0.0;
        int stl_failures = 0;
        double speedup_sum = 0.0;
        int speedup_count = 0;

        // Print header to stderr
        std::cerr << "=== Benchmark Results ===" << std::endl;
        std::cerr << "Pattern: " << escape_for_display(pattern, 60) << std::endl;
        std::cerr << "Iterations: " << BENCHMARK_ITERATIONS << std::endl;
        if (!stl_compile_result.success) {
            std::cerr << "STL Regex compile: FAILED - " << stl_compile_error << std::endl;
        } else {
            std::cerr << "STL Regex compile: OK" << std::endl;
        }
        std::cerr << std::endl;

        for (size_t i = 0; i < test_strings.size(); i++) {
            const std::string & text = test_strings[i];
            auto result = benchmark_string(stl_regex_ptr, stl_compile_error, text);
            results.push_back(result);

            total_generated_ms += result.generated_time_ms;

            // Print to stderr
            std::cerr << "Test " << (i + 1) << ": \"" << escape_for_display(text) << "\"" << std::endl;
            std::cerr << "  Generated: " << std::fixed << std::setprecision(3)
                      << result.generated_time_ms << "ms (" << result.generated_tokens.size() << " tokens)" << std::endl;

            if (result.stl_success) {
                total_stl_ms += result.stl_time_ms;
                speedup_sum += result.speedup;
                speedup_count++;
                std::cerr << "  STL Regex: " << std::fixed << std::setprecision(3)
                          << result.stl_time_ms << "ms (" << result.stl_tokens.size() << " tokens)" << std::endl;
                std::cerr << "  Speedup:   " << std::fixed << std::setprecision(1) << result.speedup << "x" << std::endl;
            } else {
                stl_failures++;
                std::cerr << "  STL Regex: ERROR - " << result.stl_error << std::endl;
            }
            std::cerr << std::endl;
        }

        // Print summary to stderr
        double average_speedup = speedup_count > 0 ? speedup_sum / speedup_count : 0.0;
        std::cerr << "=== Summary ===" << std::endl;
        std::cerr << "Total Generated: " << std::fixed << std::setprecision(3) << total_generated_ms << "ms" << std::endl;
        std::cerr << "Total STL:       " << std::fixed << std::setprecision(3) << total_stl_ms << "ms";
        if (stl_failures > 0) {
            std::cerr << " (" << stl_failures << " failures)";
        }
        std::cerr << std::endl;
        if (speedup_count > 0) {
            std::cerr << "Average Speedup: " << std::fixed << std::setprecision(1) << average_speedup << "x" << std::endl;
        }

        // Build JSON output
        json output;
        output["pattern"] = pattern;
        output["iterations"] = BENCHMARK_ITERATIONS;

        json results_json = json::array();
        for (const auto & r : results) {
            json result_json;
            result_json["input"] = r.input;

            json generated_json;
            generated_json["tokens"] = r.generated_tokens;
            generated_json["time_ms"] = r.generated_time_ms;
            generated_json["iterations"] = BENCHMARK_ITERATIONS;
            result_json["generated"] = generated_json;

            json stl_json;
            stl_json["tokens"] = r.stl_tokens;
            stl_json["time_ms"] = r.stl_time_ms;
            stl_json["iterations"] = BENCHMARK_ITERATIONS;
            stl_json["success"] = r.stl_success;
            if (!r.stl_success) {
                stl_json["error"] = r.stl_error;
            } else {
                stl_json["error"] = nullptr;
            }
            result_json["stl_regex"] = stl_json;

            result_json["speedup"] = r.speedup;
            results_json.push_back(result_json);
        }
        output["results"] = results_json;

        json summary;
        summary["total_generated_ms"] = total_generated_ms;
        summary["total_stl_ms"] = total_stl_ms;
        summary["average_speedup"] = average_speedup;
        summary["stl_failures"] = stl_failures;
        output["summary"] = summary;

        // Output JSON to stdout
        std::cout << output.dump(2) << std::endl;

        return 0;
    }
    catch (const json::exception & e) {
        std::cerr << "JSON error: " << e.what() << std::endl;
        return 1;
    }
    catch (const std::exception & e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}
