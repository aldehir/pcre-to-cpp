// Test/Benchmark harness for PCRE-to-C++ vs STL regex vs PCRE2 comparison
// Reads JSON input from stdin, runs tests or benchmarks, outputs results
//
// Input JSON:
//   mode: "test" or "bench" (default: "bench")
//   iterations: number of iterations (default: 50 for bench, 1 for test)
//   pretokenizer: STL regex pattern
//   pcre_pattern: PCRE2 pattern (optional, defaults to pretokenizer)
//   strings: array of test strings

#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <chrono>
#include <sstream>
#include <iomanip>
#include <memory>

#include "nlohmann/json.hpp"
#include "unicode.h"
#include <pcre2.h>

using json = nlohmann::json;

// Helper: measure execution time over multiple iterations
template<typename F>
double measure_time_ms(int iterations, F&& func) {
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; i++) {
        func();
    }
    auto end = std::chrono::high_resolution_clock::now();
    return std::chrono::duration<double, std::milli>(end - start).count();
}

// Helper: calculate speedup ratio
inline double calc_speedup(double baseline_ms, double generated_ms, bool success) {
    return (success && baseline_ms > 0) ? baseline_ms / generated_ms : 0.0;
}

// Forward declaration - this function is generated by pcre_to_cpp.py --name test
std::vector<size_t> unicode_regex_split_test(
    const std::string & text,
    const std::vector<size_t> & offsets
);

// Convert offset list to token strings
std::vector<std::string> offsets_to_tokens(const std::string & text, const std::vector<size_t> & offsets) {
    std::vector<std::string> tokens;
    auto cpts = unicode_cpts_from_utf8(text);

    size_t pos = 0;
    for (size_t offset : offsets) {
        std::string token;
        for (size_t i = 0; i < offset && pos + i < cpts.size(); i++) {
            token += unicode_cpt_to_utf8(cpts[pos + i]);
        }
        tokens.push_back(token);
        pos += offset;
    }

    return tokens;
}

// Unified regex result structure
struct RegexResult {
    std::vector<std::string> tokens;
    bool success = true;
    std::string error;
};

// Run STL regex with precompiled regex
RegexResult run_stl_regex(const std::regex & re, const std::string & text, bool collect_tokens = true) {
    RegexResult result;

    try {
        std::sregex_iterator iter(text.begin(), text.end(), re);
        std::sregex_iterator end;

        while (iter != end) {
            if (collect_tokens) {
                result.tokens.push_back(iter->str());
            }
            ++iter;
        }
    }
    catch (const std::regex_error & e) {
        result.success = false;
        result.error = std::string("regex_error: ") + e.what();
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = std::string("exception: ") + e.what();
    }

    return result;
}

// Try to compile STL regex, returns nullptr on failure
struct StlRegexCompileResult {
    std::unique_ptr<std::regex> regex;
    bool success;
    std::string error;
};

StlRegexCompileResult compile_stl_regex(const std::string & pattern) {
    StlRegexCompileResult result;
    result.success = true;

    try {
        result.regex = std::make_unique<std::regex>(pattern, std::regex::ECMAScript | std::regex::nosubs | std::regex::optimize);
    }
    catch (const std::regex_error & e) {
        result.success = false;
        result.error = std::string("regex_error: ") + e.what();
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = std::string("exception: ") + e.what();
    }

    return result;
}

// PCRE2 compile result structure with RAII cleanup
struct Pcre2CompileResult {
    pcre2_code * regex = nullptr;
    pcre2_match_data * match_data = nullptr;
    bool success = true;
    bool jit_available = false;
    std::string error;

    ~Pcre2CompileResult() {
        if (match_data) pcre2_match_data_free(match_data);
        if (regex) pcre2_code_free(regex);
    }

    // Prevent copying
    Pcre2CompileResult() = default;
    Pcre2CompileResult(const Pcre2CompileResult &) = delete;
    Pcre2CompileResult & operator=(const Pcre2CompileResult &) = delete;
    Pcre2CompileResult(Pcre2CompileResult && other) noexcept
        : regex(other.regex), match_data(other.match_data),
          success(other.success), jit_available(other.jit_available), error(std::move(other.error)) {
        other.regex = nullptr;
        other.match_data = nullptr;
    }
};

Pcre2CompileResult compile_pcre2_regex(const std::string & pattern) {
    Pcre2CompileResult result;

    int error_code;
    PCRE2_SIZE error_offset;

    result.regex = pcre2_compile(
        reinterpret_cast<PCRE2_SPTR>(pattern.c_str()),
        PCRE2_ZERO_TERMINATED,
        PCRE2_UTF | PCRE2_UCP,  // UTF-8 mode + Unicode properties
        &error_code,
        &error_offset,
        nullptr
    );

    if (!result.regex) {
        result.success = false;
        PCRE2_UCHAR error_buffer[256];
        pcre2_get_error_message(error_code, error_buffer, sizeof(error_buffer));
        result.error = "PCRE2 compile error at offset " + std::to_string(error_offset)
                     + ": " + reinterpret_cast<char *>(error_buffer);
        return result;
    }

    // JIT compile for performance
    int jit_rc = pcre2_jit_compile(result.regex, PCRE2_JIT_COMPLETE);
    result.jit_available = (jit_rc == 0);

    // Create match data
    result.match_data = pcre2_match_data_create_from_pattern(result.regex, nullptr);

    return result;
}

RegexResult run_pcre2_regex(pcre2_code * re, pcre2_match_data * match_data,
                            bool use_jit, const std::string & text, bool collect_tokens = true) {
    RegexResult result;

    PCRE2_SIZE start_offset = 0;
    PCRE2_SPTR subject = reinterpret_cast<PCRE2_SPTR>(text.c_str());
    PCRE2_SIZE subject_length = text.length();

    while (start_offset < subject_length) {
        int rc = use_jit
            ? pcre2_jit_match(re, subject, subject_length, start_offset, 0, match_data, nullptr)
            : pcre2_match(re, subject, subject_length, start_offset, 0, match_data, nullptr);

        if (rc < 0) {
            if (rc == PCRE2_ERROR_NOMATCH) break;
            result.success = false;
            result.error = "PCRE2 match error: " + std::to_string(rc);
            return result;
        }

        PCRE2_SIZE * ovector = pcre2_get_ovector_pointer(match_data);
        PCRE2_SIZE match_start = ovector[0];
        PCRE2_SIZE match_end = ovector[1];

        if (collect_tokens) {
            result.tokens.push_back(text.substr(match_start, match_end - match_start));
        }
        start_offset = match_end;

        // Handle zero-length matches
        if (match_start == match_end) {
            start_offset++;
        }
    }

    return result;
}

// Per-engine result structure
struct EngineResult {
    std::vector<std::string> tokens;
    double time_ms = 0.0;
    bool success = true;
    std::string error;
};

// Result structure for a single test string
struct TestResult {
    std::string input;
    EngineResult generated;
    EngineResult stl;
    EngineResult pcre2;
    double speedup_vs_stl;
    double speedup_vs_pcre2;
    bool tokens_match_pcre2;  // For test mode: do generated tokens match PCRE2?
};

// Run test/benchmark on a single string with precompiled regexes
TestResult run_single_test(const std::regex * stl_regex, const std::string & stl_error,
                           pcre2_code * pcre2_regex, pcre2_match_data * pcre2_match_data,
                           bool pcre2_jit_available, const std::string & pcre2_error,
                           const std::string & text, int iterations) {
    TestResult result;
    result.input = text;

    // Run generated code
    {
        auto cpts = unicode_cpts_from_utf8(text);
        std::vector<size_t> initial_offsets = { cpts.size() };

        // Warmup run (also gets tokens)
        result.generated.tokens = offsets_to_tokens(text, unicode_regex_split_test(text, initial_offsets));

        // Timed runs
        result.generated.time_ms = measure_time_ms(iterations, [&]() {
            volatile auto offsets = unicode_regex_split_test(text, initial_offsets);
        });
    }

    // Run STL regex (precompiled)
    if (stl_regex) {
        auto warmup_result = run_stl_regex(*stl_regex, text);
        result.stl.tokens = std::move(warmup_result.tokens);
        result.stl.success = warmup_result.success;
        result.stl.error = std::move(warmup_result.error);

        if (result.stl.success) {
            result.stl.time_ms = measure_time_ms(iterations, [&]() {
                run_stl_regex(*stl_regex, text, false);
            });
        }
    } else {
        result.stl.success = false;
        result.stl.error = stl_error;
    }

    // Run PCRE2 (precompiled)
    if (pcre2_regex) {
        auto warmup_result = run_pcre2_regex(pcre2_regex, pcre2_match_data, pcre2_jit_available, text);
        result.pcre2.tokens = std::move(warmup_result.tokens);
        result.pcre2.success = warmup_result.success;
        result.pcre2.error = std::move(warmup_result.error);

        if (result.pcre2.success) {
            result.pcre2.time_ms = measure_time_ms(iterations, [&]() {
                run_pcre2_regex(pcre2_regex, pcre2_match_data, pcre2_jit_available, text, false);
            });
        }
    } else {
        result.pcre2.success = false;
        result.pcre2.error = pcre2_error;
    }

    // Calculate speedups
    result.speedup_vs_stl = calc_speedup(result.stl.time_ms, result.generated.time_ms, result.stl.success);
    result.speedup_vs_pcre2 = calc_speedup(result.pcre2.time_ms, result.generated.time_ms, result.pcre2.success);

    // Check if generated tokens match PCRE2 (for test mode)
    result.tokens_match_pcre2 = result.pcre2.success && (result.generated.tokens == result.pcre2.tokens);

    return result;
}

// Escape string for display (truncate if too long)
std::string escape_for_display(const std::string & s, size_t max_len = 40) {
    std::string result;
    for (char c : s) {
        if (result.size() >= max_len) {
            result += "...";
            break;
        }
        if (c == '\n') result += "\\n";
        else if (c == '\r') result += "\\r";
        else if (c == '\t') result += "\\t";
        else if (c == '"') result += "\\\"";
        else result += c;
    }
    return result;
}

// Helper: create JSON for a regex engine result
json make_engine_json(const EngineResult & e) {
    return {
        {"tokens", e.tokens},
        {"time_ms", e.time_ms},
        {"success", e.success},
        {"error", e.success ? json(nullptr) : json(e.error)}
    };
}

// Helper: print benchmark result for a regex engine
void print_engine_result(const char * name, const EngineResult & e, double speedup) {
    if (e.success) {
        std::cerr << "  " << name << ": " << std::fixed << std::setprecision(3)
                  << e.time_ms << "ms (" << e.tokens.size() << " tokens)"
                  << " [" << std::setprecision(1) << speedup << "x]" << std::endl;
    } else {
        std::cerr << "  " << name << ": ERROR - " << e.error << std::endl;
    }
}

int main() {
    try {
        // Read all input from stdin
        std::stringstream buffer;
        buffer << std::cin.rdbuf();
        std::string input = buffer.str();

        // Parse input JSON
        json input_json = json::parse(input);
        std::string mode = input_json.value("mode", "bench");
        std::string stl_pattern = input_json["pretokenizer"].get<std::string>();
        std::string pcre_pattern = input_json.value("pcre_pattern", stl_pattern);
        std::vector<std::string> test_strings = input_json["strings"].get<std::vector<std::string>>();

        // Get iterations (default depends on mode)
        int default_iterations = (mode == "test") ? 1 : 50;
        int iterations = input_json.value("iterations", default_iterations);

        bool is_test_mode = (mode == "test");

        // Precompile STL regex once
        auto stl_compile_result = compile_stl_regex(stl_pattern);
        std::regex * stl_regex_ptr = stl_compile_result.regex.get();
        std::string stl_compile_error = stl_compile_result.error;

        // Precompile PCRE2 regex once
        auto pcre2_compile_result = compile_pcre2_regex(pcre_pattern);
        pcre2_code * pcre2_regex_ptr = pcre2_compile_result.regex;
        pcre2_match_data * pcre2_match_data_ptr = pcre2_compile_result.match_data;
        std::string pcre2_compile_error = pcre2_compile_result.error;

        // Run tests/benchmarks
        std::vector<TestResult> results;
        double total_generated_ms = 0.0;
        double total_stl_ms = 0.0;
        double total_pcre2_ms = 0.0;
        int stl_failures = 0;
        int pcre2_failures = 0;
        double speedup_stl_sum = 0.0;
        double speedup_pcre2_sum = 0.0;
        int speedup_stl_count = 0;
        int speedup_pcre2_count = 0;
        int token_mismatches = 0;

        // Print header to stderr
        if (is_test_mode) {
            std::cerr << "=== Test Results ===" << std::endl;
        } else {
            std::cerr << "=== Benchmark Results ===" << std::endl;
        }
        std::cerr << "Mode: " << mode << std::endl;
        std::cerr << "Iterations: " << iterations << std::endl;
        std::cerr << "STL Pattern:   " << escape_for_display(stl_pattern, 60) << std::endl;
        std::cerr << "PCRE Pattern:  " << escape_for_display(pcre_pattern, 60) << std::endl;

        if (!stl_compile_result.success) {
            std::cerr << "STL Regex compile:   FAILED - " << stl_compile_error << std::endl;
        } else {
            std::cerr << "STL Regex compile:   OK" << std::endl;
        }
        if (!pcre2_compile_result.success) {
            std::cerr << "PCRE2 Regex compile: FAILED - " << pcre2_compile_error << std::endl;
        } else {
            std::cerr << "PCRE2 Regex compile: OK (JIT: "
                      << (pcre2_compile_result.jit_available ? "enabled" : "disabled") << ")" << std::endl;
        }
        std::cerr << std::endl;

        for (size_t i = 0; i < test_strings.size(); i++) {
            const std::string & text = test_strings[i];
            auto result = run_single_test(stl_regex_ptr, stl_compile_error,
                                          pcre2_regex_ptr, pcre2_match_data_ptr,
                                          pcre2_compile_result.jit_available,
                                          pcre2_compile_error, text, iterations);
            results.push_back(result);

            total_generated_ms += result.generated.time_ms;

            if (is_test_mode) {
                // Test mode: focus on pass/fail
                std::string status = result.tokens_match_pcre2 ? "PASS" : "FAIL";
                std::cerr << "[" << status << "] Test " << (i + 1) << ": \""
                          << escape_for_display(text) << "\" ("
                          << result.generated.tokens.size() << " tokens)" << std::endl;

                if (!result.tokens_match_pcre2) {
                    token_mismatches++;
                    // Show mismatch details
                    std::cerr << "  Generated: " << result.generated.tokens.size() << " tokens" << std::endl;
                    std::cerr << "  PCRE2:     " << result.pcre2.tokens.size() << " tokens" << std::endl;
                    size_t max_len = std::max(result.generated.tokens.size(), result.pcre2.tokens.size());
                    for (size_t j = 0; j < std::min(max_len, size_t(5)); j++) {
                        std::string gen_tok = j < result.generated.tokens.size()
                            ? ("\"" + escape_for_display(result.generated.tokens[j], 20) + "\"")
                            : "<missing>";
                        std::string pcre_tok = j < result.pcre2.tokens.size()
                            ? ("\"" + escape_for_display(result.pcre2.tokens[j], 20) + "\"")
                            : "<missing>";
                        if (gen_tok != pcre_tok) {
                            std::cerr << "    [" << j << "] Gen: " << gen_tok << " vs PCRE2: " << pcre_tok << std::endl;
                        }
                    }
                    if (max_len > 5) {
                        std::cerr << "    ... and " << (max_len - 5) << " more tokens" << std::endl;
                    }
                }

                // Show STL info (informational only)
                if (result.stl.success) {
                    bool stl_matches = (result.generated.tokens == result.stl.tokens);
                    std::cerr << "  STL: " << (stl_matches ? "matches" : "differs") << std::endl;
                } else {
                    std::cerr << "  STL: " << result.stl.error << std::endl;
                }
            } else {
                // Bench mode: show timing details
                std::cerr << "Test " << (i + 1) << ": \"" << escape_for_display(text) << "\"" << std::endl;
                std::cerr << "  Generated: " << std::fixed << std::setprecision(3)
                          << result.generated.time_ms << "ms (" << result.generated.tokens.size() << " tokens)" << std::endl;

                if (result.stl.success) {
                    total_stl_ms += result.stl.time_ms;
                    speedup_stl_sum += result.speedup_vs_stl;
                    speedup_stl_count++;
                } else {
                    stl_failures++;
                }
                print_engine_result("STL Regex", result.stl, result.speedup_vs_stl);

                if (result.pcre2.success) {
                    total_pcre2_ms += result.pcre2.time_ms;
                    speedup_pcre2_sum += result.speedup_vs_pcre2;
                    speedup_pcre2_count++;
                } else {
                    pcre2_failures++;
                }
                print_engine_result("PCRE2    ", result.pcre2, result.speedup_vs_pcre2);

                if (!result.tokens_match_pcre2) {
                    token_mismatches++;
                    std::cerr << "  WARNING: Token mismatch vs PCRE2!" << std::endl;
                }
            }
            std::cerr << std::endl;
        }

        // Print summary to stderr
        double average_speedup_stl = speedup_stl_count > 0 ? speedup_stl_sum / speedup_stl_count : 0.0;
        double average_speedup_pcre2 = speedup_pcre2_count > 0 ? speedup_pcre2_sum / speedup_pcre2_count : 0.0;

        std::cerr << "=== Summary ===" << std::endl;
        if (is_test_mode) {
            int passed = static_cast<int>(test_strings.size()) - token_mismatches;
            std::cerr << "Passed: " << passed << "/" << test_strings.size() << std::endl;
            if (token_mismatches > 0) {
                std::cerr << "FAILED: " << token_mismatches << " test(s) had token mismatches vs PCRE2" << std::endl;
            } else {
                std::cerr << "All tests passed!" << std::endl;
            }
        } else {
            std::cerr << "Total Generated: " << std::fixed << std::setprecision(3) << total_generated_ms << "ms" << std::endl;
            std::cerr << "Total STL:       " << std::fixed << std::setprecision(3) << total_stl_ms << "ms";
            if (stl_failures > 0) {
                std::cerr << " (" << stl_failures << " failures)";
            }
            std::cerr << std::endl;
            std::cerr << "Total PCRE2:     " << std::fixed << std::setprecision(3) << total_pcre2_ms << "ms";
            if (pcre2_failures > 0) {
                std::cerr << " (" << pcre2_failures << " failures)";
            }
            std::cerr << std::endl;
            if (speedup_stl_count > 0) {
                std::cerr << "Speedup vs STL:   " << std::fixed << std::setprecision(1) << average_speedup_stl << "x" << std::endl;
            }
            if (speedup_pcre2_count > 0) {
                std::cerr << "Speedup vs PCRE2: " << std::fixed << std::setprecision(1) << average_speedup_pcre2 << "x" << std::endl;
            }
            if (token_mismatches > 0) {
                std::cerr << "WARNING: " << token_mismatches << " test(s) had token mismatches vs PCRE2" << std::endl;
            }
        }

        // Build JSON output
        json output;
        output["mode"] = mode;
        output["stl_pattern"] = stl_pattern;
        output["pcre_pattern"] = pcre_pattern;
        output["iterations"] = iterations;

        json results_json = json::array();
        for (const auto & r : results) {
            results_json.push_back({
                {"input", r.input},
                {"generated", make_engine_json(r.generated)},
                {"stl_regex", make_engine_json(r.stl)},
                {"pcre2", make_engine_json(r.pcre2)},
                {"speedup_vs_stl", r.speedup_vs_stl},
                {"speedup_vs_pcre2", r.speedup_vs_pcre2},
                {"tokens_match_pcre2", r.tokens_match_pcre2}
            });
        }
        output["results"] = results_json;

        output["summary"] = {
            {"total_generated_ms", total_generated_ms},
            {"total_stl_ms", total_stl_ms},
            {"total_pcre2_ms", total_pcre2_ms},
            {"average_speedup_vs_stl", average_speedup_stl},
            {"average_speedup_vs_pcre2", average_speedup_pcre2},
            {"stl_failures", stl_failures},
            {"pcre2_failures", pcre2_failures},
            {"token_mismatches", token_mismatches},
            {"all_passed", token_mismatches == 0}
        };

        // Output JSON to stdout
        std::cout << output.dump(2) << std::endl;

        // Return non-zero exit code if tests failed
        return (is_test_mode && token_mismatches > 0) ? 1 : 0;
    }
    catch (const json::exception & e) {
        std::cerr << "JSON error: " << e.what() << std::endl;
        return 1;
    }
    catch (const std::exception & e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}
