// Test/Benchmark harness for PCRE-to-C++ vs STL regex vs PCRE2 comparison
// Reads JSON input from stdin, runs tests or benchmarks, outputs results
//
// Input JSON:
//   mode: "test" or "bench" (default: "bench")
//   iterations: number of iterations (default: 50 for bench, 1 for test)
//   pretokenizer: STL regex pattern
//   pcre_pattern: PCRE2 pattern (optional, defaults to pretokenizer)
//   strings: array of test strings

#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <chrono>
#include <sstream>
#include <iomanip>
#include <memory>

#include "nlohmann/json.hpp"
#include "unicode.h"
#include <pcre2.h>

#ifdef HAS_BOOST_REGEX
#include <boost/regex.hpp>
#endif

using json = nlohmann::json;

// Timing result: total time + per-iteration breakdown
struct TimingResult {
    double total_ms;
    std::vector<double> iteration_times_ms;
};

// Helper: measure execution time over multiple iterations (with per-iteration timing)
template<typename F>
TimingResult measure_time_ms(int iterations, F&& func) {
    TimingResult result;
    result.iteration_times_ms.reserve(iterations);

    auto outer_start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; i++) {
        auto iter_start = std::chrono::high_resolution_clock::now();
        func();
        auto iter_end = std::chrono::high_resolution_clock::now();
        result.iteration_times_ms.push_back(
            std::chrono::duration<double, std::milli>(iter_end - iter_start).count());
    }
    auto outer_end = std::chrono::high_resolution_clock::now();
    result.total_ms = std::chrono::duration<double, std::milli>(outer_end - outer_start).count();

    return result;
}

// Helper: calculate speedup ratio
inline double calc_speedup(double baseline_ms, double generated_ms, bool success) {
    return (success && baseline_ms > 0) ? baseline_ms / generated_ms : 0.0;
}

// Forward declaration - this function is generated by pcre_to_cpp.py --name test
std::vector<size_t> unicode_regex_split_test(
    const std::string & text,
    const std::vector<size_t> & offsets
);

// Convert offset list to token strings
std::vector<std::string> offsets_to_tokens(const std::string & text, const std::vector<size_t> & offsets) {
    std::vector<std::string> tokens;
    auto cpts = unicode_cpts_from_utf8(text);

    size_t pos = 0;
    for (size_t offset : offsets) {
        std::string token;
        for (size_t i = 0; i < offset && pos + i < cpts.size(); i++) {
            token += unicode_cpt_to_utf8(cpts[pos + i]);
        }
        tokens.push_back(token);
        pos += offset;
    }

    return tokens;
}

// Unified regex result structure
struct RegexResult {
    std::vector<std::string> tokens;
    bool success = true;
    std::string error;
};

// Run STL regex with precompiled regex
RegexResult run_stl_regex(const std::regex & re, const std::string & text, bool collect_tokens = true) {
    RegexResult result;

    try {
        std::sregex_iterator iter(text.begin(), text.end(), re);
        std::sregex_iterator end;

        while (iter != end) {
            if (collect_tokens) {
                result.tokens.push_back(iter->str());
            }
            ++iter;
        }
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = e.what();
    }

    return result;
}

// Try to compile STL regex, returns nullptr on failure
struct StlRegexCompileResult {
    std::unique_ptr<std::regex> regex;
    bool success;
    std::string error;
};

StlRegexCompileResult compile_stl_regex(const std::string & pattern) {
    StlRegexCompileResult result;
    result.success = true;

    try {
        result.regex = std::make_unique<std::regex>(pattern, std::regex::ECMAScript | std::regex::nosubs | std::regex::optimize);
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = e.what();
    }

    return result;
}

// Boost.Regex support (optional, for benchmarking)
#ifdef HAS_BOOST_REGEX
struct BoostRegexCompileResult {
    std::unique_ptr<boost::regex> regex;
    bool success;
    std::string error;
};

BoostRegexCompileResult compile_boost_regex(const std::string & pattern) {
    BoostRegexCompileResult result;
    result.success = true;

    try {
        result.regex = std::make_unique<boost::regex>(pattern, boost::regex::perl | boost::regex::nosubs | boost::regex::optimize);
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = e.what();
    }

    return result;
}

RegexResult run_boost_regex(const boost::regex & re, const std::string & text, bool collect_tokens = true) {
    RegexResult result;

    try {
        boost::sregex_iterator iter(text.begin(), text.end(), re);
        boost::sregex_iterator end;

        while (iter != end) {
            if (collect_tokens) {
                result.tokens.push_back(iter->str());
            }
            ++iter;
        }
    }
    catch (const std::exception & e) {
        result.success = false;
        result.error = e.what();
    }

    return result;
}
#endif

// PCRE2 compile result structure with RAII cleanup
struct Pcre2CompileResult {
    pcre2_code * regex = nullptr;
    pcre2_match_data * match_data = nullptr;
    bool success = true;
    bool jit_available = false;
    std::string error;

    ~Pcre2CompileResult() {
        if (match_data) pcre2_match_data_free(match_data);
        if (regex) pcre2_code_free(regex);
    }

    // Prevent copying
    Pcre2CompileResult() = default;
    Pcre2CompileResult(const Pcre2CompileResult &) = delete;
    Pcre2CompileResult & operator=(const Pcre2CompileResult &) = delete;
    Pcre2CompileResult(Pcre2CompileResult && other) noexcept
        : regex(other.regex), match_data(other.match_data),
          success(other.success), jit_available(other.jit_available), error(std::move(other.error)) {
        other.regex = nullptr;
        other.match_data = nullptr;
    }
};

Pcre2CompileResult compile_pcre2_regex(const std::string & pattern) {
    Pcre2CompileResult result;

    int error_code;
    PCRE2_SIZE error_offset;

    result.regex = pcre2_compile(
        reinterpret_cast<PCRE2_SPTR>(pattern.c_str()),
        PCRE2_ZERO_TERMINATED,
        PCRE2_UTF | PCRE2_UCP,  // UTF-8 mode + Unicode properties
        &error_code,
        &error_offset,
        nullptr
    );

    if (!result.regex) {
        result.success = false;
        PCRE2_UCHAR error_buffer[256];
        pcre2_get_error_message(error_code, error_buffer, sizeof(error_buffer));
        result.error = "PCRE2 compile error at offset " + std::to_string(error_offset)
                     + ": " + reinterpret_cast<char *>(error_buffer);
        return result;
    }

    // JIT compile for performance
    int jit_rc = pcre2_jit_compile(result.regex, PCRE2_JIT_COMPLETE);
    result.jit_available = (jit_rc == 0);

    // Create match data
    result.match_data = pcre2_match_data_create_from_pattern(result.regex, nullptr);

    return result;
}

RegexResult run_pcre2_regex(pcre2_code * re, pcre2_match_data * match_data,
                            bool use_jit, const std::string & text, bool collect_tokens = true) {
    RegexResult result;

    PCRE2_SIZE start_offset = 0;
    PCRE2_SPTR subject = reinterpret_cast<PCRE2_SPTR>(text.c_str());
    PCRE2_SIZE subject_length = text.length();

    while (start_offset < subject_length) {
        int rc = use_jit
            ? pcre2_jit_match(re, subject, subject_length, start_offset, 0, match_data, nullptr)
            : pcre2_match(re, subject, subject_length, start_offset, 0, match_data, nullptr);

        if (rc < 0) {
            if (rc == PCRE2_ERROR_NOMATCH) break;
            result.success = false;
            result.error = "PCRE2 match error: " + std::to_string(rc);
            return result;
        }

        PCRE2_SIZE * ovector = pcre2_get_ovector_pointer(match_data);
        PCRE2_SIZE match_start = ovector[0];
        PCRE2_SIZE match_end = ovector[1];

        if (collect_tokens) {
            result.tokens.push_back(text.substr(match_start, match_end - match_start));
        }
        start_offset = match_end;

        // Handle zero-length matches
        if (match_start == match_end) {
            start_offset++;
        }
    }

    return result;
}

// Token diff entry for mismatches
struct TokenDiff {
    size_t index;
    std::string expected;  // from generated
    std::string actual;    // from this engine
};

// Per-engine result structure
struct EngineResult {
    std::vector<std::string> tokens;
    double time_ms = 0.0;
    std::vector<double> iteration_times_ms;  // per-iteration timing breakdown
    bool success = true;
    std::string error;
    double speedup = 1.0;           // speedup vs generated (generated is always 1.0)
    bool tokens_match = true;       // whether tokens match generated
    std::vector<TokenDiff> diffs;   // token differences (populated in test mode)
};

// Result structure for a single test string
struct TestResult {
    std::string input;
    size_t input_length_bytes = 0;
    size_t input_length_codepoints = 0;
    EngineResult generated;
    EngineResult stl;
    EngineResult boost;
    EngineResult pcre2;
};

// Calculate token diffs between expected (generated) and actual (engine) tokens
std::vector<TokenDiff> calculate_token_diffs(const std::vector<std::string> & expected,
                                              const std::vector<std::string> & actual) {
    std::vector<TokenDiff> diffs;
    size_t max_len = std::max(expected.size(), actual.size());

    for (size_t i = 0; i < max_len; i++) {
        std::string exp_tok = i < expected.size() ? expected[i] : "";
        std::string act_tok = i < actual.size() ? actual[i] : "";

        if (exp_tok != act_tok) {
            diffs.push_back({i, exp_tok, act_tok});
        }
    }

    return diffs;
}

// Run test/benchmark on a single string with precompiled regexes
TestResult run_single_test(const StlRegexCompileResult & stl_compiled,
#ifdef HAS_BOOST_REGEX
                           const BoostRegexCompileResult & boost_compiled,
#endif
                           const Pcre2CompileResult & pcre2_compiled,
                           const std::string & text, int iterations, bool is_test_mode) {
    TestResult result;
    result.input = text;
    result.input_length_bytes = text.size();

    // Hoist codepoint conversion â€” reuse for input length and generated code
    auto cpts = unicode_cpts_from_utf8(text);
    result.input_length_codepoints = cpts.size();

    // Run generated code (baseline - speedup is always 1.0, tokens always match itself)
    {
        std::vector<size_t> initial_offsets = { cpts.size() };

        // Warmup run (also gets tokens)
        result.generated.tokens = offsets_to_tokens(text, unicode_regex_split_test(text, initial_offsets));

        // Timed runs
        auto timing = measure_time_ms(iterations, [&]() {
            volatile auto offsets = unicode_regex_split_test(text, initial_offsets);
        });
        result.generated.time_ms = timing.total_ms;
        result.generated.iteration_times_ms = std::move(timing.iteration_times_ms);
        // generated is the baseline: speedup = 1.0, tokens_match = true (defaults)
    }

    // Run STL regex (precompiled) - skip in test mode since we only compare against PCRE2
    if (!is_test_mode) {
        if (stl_compiled.regex) {
            auto warmup_result = run_stl_regex(*stl_compiled.regex, text);
            result.stl.tokens = std::move(warmup_result.tokens);
            result.stl.success = warmup_result.success;
            result.stl.error = std::move(warmup_result.error);

            if (result.stl.success) {
                auto stl_timing = measure_time_ms(iterations, [&]() {
                    run_stl_regex(*stl_compiled.regex, text, false);
                });
                result.stl.time_ms = stl_timing.total_ms;
                result.stl.iteration_times_ms = std::move(stl_timing.iteration_times_ms);
                result.stl.speedup = calc_speedup(result.stl.time_ms, result.generated.time_ms, true);
                result.stl.tokens_match = (result.generated.tokens == result.stl.tokens);
            }
        } else {
            result.stl.success = false;
            result.stl.error = stl_compiled.error;
            result.stl.tokens_match = false;
        }
    }

    // Run Boost.Regex (precompiled) - skip in test mode
#ifdef HAS_BOOST_REGEX
    if (!is_test_mode) {
        if (boost_compiled.regex) {
            auto warmup_result = run_boost_regex(*boost_compiled.regex, text);
            result.boost.tokens = std::move(warmup_result.tokens);
            result.boost.success = warmup_result.success;
            result.boost.error = std::move(warmup_result.error);

            if (result.boost.success) {
                auto boost_timing = measure_time_ms(iterations, [&]() {
                    run_boost_regex(*boost_compiled.regex, text, false);
                });
                result.boost.time_ms = boost_timing.total_ms;
                result.boost.iteration_times_ms = std::move(boost_timing.iteration_times_ms);
                result.boost.speedup = calc_speedup(result.boost.time_ms, result.generated.time_ms, true);
                result.boost.tokens_match = (result.generated.tokens == result.boost.tokens);
            }
        } else {
            result.boost.success = false;
            result.boost.error = boost_compiled.error;
            result.boost.tokens_match = false;
        }
    }
#endif

    // Run PCRE2 (precompiled)
    if (pcre2_compiled.regex) {
        auto warmup_result = run_pcre2_regex(pcre2_compiled.regex, pcre2_compiled.match_data,
                                              pcre2_compiled.jit_available, text);
        result.pcre2.tokens = std::move(warmup_result.tokens);
        result.pcre2.success = warmup_result.success;
        result.pcre2.error = std::move(warmup_result.error);

        if (result.pcre2.success) {
            auto pcre2_timing = measure_time_ms(iterations, [&]() {
                run_pcre2_regex(pcre2_compiled.regex, pcre2_compiled.match_data,
                                pcre2_compiled.jit_available, text, false);
            });
            result.pcre2.time_ms = pcre2_timing.total_ms;
            result.pcre2.iteration_times_ms = std::move(pcre2_timing.iteration_times_ms);
            result.pcre2.speedup = calc_speedup(result.pcre2.time_ms, result.generated.time_ms, true);

            // Calculate token match and diffs
            if (is_test_mode) {
                result.pcre2.diffs = calculate_token_diffs(result.generated.tokens, result.pcre2.tokens);
                result.pcre2.tokens_match = result.pcre2.diffs.empty();
            } else {
                result.pcre2.tokens_match = (result.generated.tokens == result.pcre2.tokens);
            }
        }
    } else {
        result.pcre2.success = false;
        result.pcre2.error = pcre2_compiled.error;
        result.pcre2.tokens_match = false;
    }

    return result;
}

// Escape string for display (truncate if too long)
std::string escape_for_display(const std::string & s, size_t max_len = 40) {
    std::string result;
    for (char c : s) {
        if (result.size() >= max_len) {
            result += "...";
            break;
        }
        if (c == '\n') result += "\\n";
        else if (c == '\r') result += "\\r";
        else if (c == '\t') result += "\\t";
        else if (c == '"') result += "\\\"";
        else result += c;
    }
    return result;
}

// Helper: create JSON for a regex engine result
json make_engine_json(const EngineResult & e) {
    json result = {
        {"tokens", e.tokens},
        {"time_ms", e.time_ms},
        {"iteration_times_ms", e.iteration_times_ms},
        {"success", e.success},
        {"error", e.success ? json(nullptr) : json(e.error)},
        {"speedup", e.speedup},
        {"tokens_match", e.tokens_match}
    };

    if (!e.diffs.empty()) {
        json diffs_json = json::array();
        for (const auto & d : e.diffs) {
            diffs_json.push_back({
                {"index", d.index},
                {"expected", d.expected},
                {"actual", d.actual}
            });
        }
        result["diffs"] = diffs_json;
    }

    return result;
}

// Helper: print benchmark result for a regex engine
void print_engine_result(const char * name, const EngineResult & e) {
    if (e.success) {
        std::cerr << "  " << name << ": " << std::fixed << std::setprecision(3)
                  << e.time_ms << "ms (" << e.tokens.size() << " tokens)"
                  << " [" << std::setprecision(1) << e.speedup << "x]" << std::endl;
    } else {
        std::cerr << "  " << name << ": ERROR - " << e.error << std::endl;
    }
}

int run() {
    // Read all input from stdin
    std::stringstream buffer;
    buffer << std::cin.rdbuf();
    std::string input = buffer.str();

    // Parse input JSON
    json input_json = json::parse(input);
    std::string mode = input_json.value("mode", "bench");
    std::string stl_pattern = input_json["pretokenizer"].get<std::string>();
    std::string pcre_pattern = input_json.value("pcre_pattern", stl_pattern);
    std::vector<std::string> test_strings = input_json["strings"].get<std::vector<std::string>>();

    // Get iterations (default depends on mode)
    int default_iterations = (mode == "test") ? 1 : 50;
    int iterations = input_json.value("iterations", default_iterations);

    bool is_test_mode = (mode == "test");

    // Precompile regexes (skip STL/Boost in test mode - we only compare against PCRE2)
    StlRegexCompileResult stl_compile_result;
#ifdef HAS_BOOST_REGEX
    BoostRegexCompileResult boost_compile_result;
#endif
    if (!is_test_mode) {
        stl_compile_result = compile_stl_regex(stl_pattern);
#ifdef HAS_BOOST_REGEX
        boost_compile_result = compile_boost_regex(stl_pattern);
#endif
    }
    auto pcre2_compile_result = compile_pcre2_regex(pcre_pattern);

    // Run tests/benchmarks
    std::vector<TestResult> results;

    // Print header to stderr
    if (is_test_mode) {
        std::cerr << "=== Test Results ===" << std::endl;
    } else {
        std::cerr << "=== Benchmark Results ===" << std::endl;
    }
    std::cerr << "Mode: " << mode << std::endl;
    std::cerr << "Iterations: " << iterations << std::endl;
    if (!is_test_mode) {
        std::cerr << "STL Pattern:   " << escape_for_display(stl_pattern, 60) << std::endl;
    }
    std::cerr << "PCRE Pattern:  " << escape_for_display(pcre_pattern, 60) << std::endl;

    if (!is_test_mode) {
        if (!stl_compile_result.success) {
            std::cerr << "STL Regex compile:   FAILED - " << stl_compile_result.error << std::endl;
        } else {
            std::cerr << "STL Regex compile:   OK" << std::endl;
        }
#ifdef HAS_BOOST_REGEX
        if (!boost_compile_result.success) {
            std::cerr << "Boost Regex compile: FAILED - " << boost_compile_result.error << std::endl;
        } else {
            std::cerr << "Boost Regex compile: OK" << std::endl;
        }
#endif
    }
    if (!pcre2_compile_result.success) {
        std::cerr << "PCRE2 Regex compile: FAILED - " << pcre2_compile_result.error << std::endl;
    } else {
        std::cerr << "PCRE2 Regex compile: OK (JIT: "
                  << (pcre2_compile_result.jit_available ? "enabled" : "disabled") << ")" << std::endl;
    }
    std::cerr << std::endl;

    for (size_t i = 0; i < test_strings.size(); i++) {
        const std::string & text = test_strings[i];
        auto result = run_single_test(
            stl_compile_result,
#ifdef HAS_BOOST_REGEX
            boost_compile_result,
#endif
            pcre2_compile_result,
            text, iterations, is_test_mode);
        results.push_back(result);

        if (is_test_mode) {
            // Test mode: focus on pass/fail
            std::string status = result.pcre2.tokens_match ? "PASS" : "FAIL";
            std::cerr << "[" << status << "] Test " << (i + 1) << ": \""
                      << escape_for_display(text) << "\" ("
                      << result.generated.tokens.size() << " tokens)" << std::endl;

            if (!result.pcre2.tokens_match) {
                // Show mismatch details using precomputed diffs
                std::cerr << "  Generated: " << result.generated.tokens.size() << " tokens" << std::endl;
                std::cerr << "  PCRE2:     " << result.pcre2.tokens.size() << " tokens" << std::endl;
                size_t shown = 0;
                for (const auto & diff : result.pcre2.diffs) {
                    if (shown >= 5) {
                        std::cerr << "    ... and " << (result.pcre2.diffs.size() - 5) << " more differences" << std::endl;
                        break;
                    }
                    std::string gen_tok = diff.expected.empty() ? "<missing>" : ("\"" + escape_for_display(diff.expected, 20) + "\"");
                    std::string pcre_tok = diff.actual.empty() ? "<missing>" : ("\"" + escape_for_display(diff.actual, 20) + "\"");
                    std::cerr << "    [" << diff.index << "] Gen: " << gen_tok << " vs PCRE2: " << pcre_tok << std::endl;
                    shown++;
                }
            }
        } else {
            // Bench mode: show timing details
            std::cerr << "Test " << (i + 1) << ": \"" << escape_for_display(text) << "\"" << std::endl;
            std::cerr << "  Generated: " << std::fixed << std::setprecision(3)
                      << result.generated.time_ms << "ms (" << result.generated.tokens.size() << " tokens)" << std::endl;
            print_engine_result("STL Regex  ", result.stl);
#ifdef HAS_BOOST_REGEX
            print_engine_result("Boost Regex", result.boost);
#endif
            print_engine_result("PCRE2      ", result.pcre2);

            if (!result.pcre2.tokens_match) {
                std::cerr << "  WARNING: Token mismatch vs PCRE2!" << std::endl;
            }
        }
        std::cerr << std::endl;
    }

    // Compute summary statistics from results
    double total_generated_ms = 0.0, total_stl_ms = 0.0, total_boost_ms = 0.0, total_pcre2_ms = 0.0;
    int stl_failures = 0, boost_failures = 0, pcre2_failures = 0;
    int token_mismatches = 0;

    for (const auto & r : results) {
        total_generated_ms += r.generated.time_ms;
        if (!r.pcre2.tokens_match) token_mismatches++;
        if (r.stl.success) {
            total_stl_ms += r.stl.time_ms;
        } else if (!is_test_mode) {
            stl_failures++;
        }
        if (r.boost.success && r.boost.time_ms > 0) {
            total_boost_ms += r.boost.time_ms;
        } else if (!is_test_mode && r.boost.error.size() > 0) {
            boost_failures++;
        }
        if (r.pcre2.success) {
            total_pcre2_ms += r.pcre2.time_ms;
        } else {
            pcre2_failures++;
        }
    }

    double average_speedup_stl = (total_stl_ms > 0 && total_generated_ms > 0) ? total_stl_ms / total_generated_ms : 0.0;
    double average_speedup_boost = (total_boost_ms > 0 && total_generated_ms > 0) ? total_boost_ms / total_generated_ms : 0.0;
    double average_speedup_pcre2 = (total_pcre2_ms > 0 && total_generated_ms > 0) ? total_pcre2_ms / total_generated_ms : 0.0;

    // Print summary to stderr
    std::cerr << "=== Summary ===" << std::endl;
    if (is_test_mode) {
        int passed = static_cast<int>(results.size()) - token_mismatches;
        std::cerr << "Passed: " << passed << "/" << results.size() << std::endl;
        if (token_mismatches > 0) {
            std::cerr << "FAILED: " << token_mismatches << " test(s) had token mismatches vs PCRE2" << std::endl;
        } else {
            std::cerr << "All tests passed!" << std::endl;
        }
    } else {
        std::cerr << std::fixed << std::setprecision(3);
        std::cerr << "Total Generated: " << total_generated_ms << "ms" << std::endl;
        std::cerr << "Total STL:       " << total_stl_ms << "ms";
        if (stl_failures > 0) std::cerr << " (" << stl_failures << " failures)";
        std::cerr << std::endl;
        if (total_boost_ms > 0) {
            std::cerr << "Total Boost:     " << total_boost_ms << "ms";
            if (boost_failures > 0) std::cerr << " (" << boost_failures << " failures)";
            std::cerr << std::endl;
        }
        std::cerr << "Total PCRE2:     " << total_pcre2_ms << "ms";
        if (pcre2_failures > 0) std::cerr << " (" << pcre2_failures << " failures)";
        std::cerr << std::endl;
        std::cerr << std::setprecision(1);
        if (average_speedup_stl > 0) {
            std::cerr << "Speedup vs STL:   " << average_speedup_stl << "x" << std::endl;
        }
        if (average_speedup_boost > 0) {
            std::cerr << "Speedup vs Boost: " << average_speedup_boost << "x" << std::endl;
        }
        if (average_speedup_pcre2 > 0) {
            std::cerr << "Speedup vs PCRE2: " << average_speedup_pcre2 << "x" << std::endl;
        }
        if (token_mismatches > 0) {
            std::cerr << "WARNING: " << token_mismatches << " test(s) had token mismatches vs PCRE2" << std::endl;
        }
    }

    // Build JSON output
    json results_json = json::array();
    for (const auto & r : results) {
        results_json.push_back({
            {"input", r.input},
            {"input_length_bytes", r.input_length_bytes},
            {"input_length_codepoints", r.input_length_codepoints},
            {"generated", make_engine_json(r.generated)},
            {"stl_regex", make_engine_json(r.stl)},
            {"boost_regex", make_engine_json(r.boost)},
            {"pcre2", make_engine_json(r.pcre2)}
        });
    }

    json output = {
        {"mode", mode},
        {"stl_pattern", stl_pattern},
        {"pcre_pattern", pcre_pattern},
        {"iterations", iterations},
        {"results", results_json},
        {"summary", {
            {"total_generated_ms", total_generated_ms},
            {"total_stl_ms", total_stl_ms},
            {"total_boost_ms", total_boost_ms},
            {"total_pcre2_ms", total_pcre2_ms},
            {"average_speedup_vs_stl", average_speedup_stl},
            {"average_speedup_vs_boost", average_speedup_boost},
            {"average_speedup_vs_pcre2", average_speedup_pcre2},
            {"stl_failures", stl_failures},
            {"boost_failures", boost_failures},
            {"pcre2_failures", pcre2_failures},
            {"token_mismatches", token_mismatches},
            {"all_passed", token_mismatches == 0}
        }}
    };

    // Output JSON to stdout
    std::cout << output.dump(2) << std::endl;

    // Return non-zero exit code if tests failed
    return (is_test_mode && token_mismatches > 0) ? 1 : 0;
}

int main() {
    try {
        return run();
    }
    catch (const json::exception & e) {
        std::cerr << "JSON error: " << e.what() << std::endl;
        return 1;
    }
    catch (const std::exception & e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}
