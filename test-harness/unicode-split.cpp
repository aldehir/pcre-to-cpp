// Auto-generated by pcre_to_cpp.py
// Do not edit manually

#include "unicode.h"

#include <string>
#include <vector>
#include <cstdint>

// Required helpers (implement these):
// std::vector<uint32_t> unicode_cpts_from_utf8(const std::string & utf8);
// unicode_cpt_flags unicode_cpt_flags_from_cpt(uint32_t cpt);
// uint32_t unicode_tolower(uint32_t cpt);
// bool unicode_cpt_is_han(uint32_t cpt);

std::vector<size_t> unicode_split(
    const std::string & text,
    const std::vector<size_t> & offsets
) {
    std::vector<size_t> bpe_offsets;
    bpe_offsets.reserve(offsets.size());
    
    const auto cpts = unicode_cpts_from_utf8(text);
    
    size_t start = 0;
    for (auto offset : offsets) {
        const size_t offset_ini = start;
        const size_t offset_end = start + offset;
        start = offset_end;
        
        static const uint32_t OUT_OF_RANGE = 0xFFFFFFFF;
        auto _get_cpt = [&](const size_t pos) -> uint32_t {
            return (offset_ini <= pos && pos < offset_end) ? cpts[pos] : OUT_OF_RANGE;
        };
        
        auto _get_flags = [&](const size_t pos) -> unicode_cpt_flags {
            return (offset_ini <= pos && pos < offset_end) ? unicode_cpt_flags_from_cpt(cpts[pos]) : unicode_cpt_flags{};
        };
        
        size_t _prev_end = offset_ini;
        auto _add_token = [&](const size_t end) -> size_t {
            size_t len = end - _prev_end;
            if (len > 0) {
                bpe_offsets.push_back(len);
            }
            _prev_end = end;
            return len;
        };
        
        for (size_t pos = offset_ini; pos < offset_end; ) {
            
            // Alternative: (?i:'s|'t|'re|'ve|'m|'ll|'d)
            {
                size_t match_pos = pos;
                bool matched = true;
                
                // Case-insensitive group
                // Nested alternation
                {
                    size_t alt_save = match_pos;
                    bool alt_matched = false;
                    if (matched && _get_cpt(match_pos) == 39) { // '\''
                        match_pos++;
                    } else if (matched) { matched = false; }
                    if (matched && unicode_tolower(_get_cpt(match_pos)) == 115) { // 's' (case-insensitive)
                        match_pos++;
                    } else if (matched) { matched = false; }
                    if (matched) alt_matched = true;
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && _get_cpt(match_pos) == 39) { // '\''
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 116) { // 't' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && _get_cpt(match_pos) == 39) { // '\''
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 114) { // 'r' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 101) { // 'e' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && _get_cpt(match_pos) == 39) { // '\''
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 118) { // 'v' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 101) { // 'e' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && _get_cpt(match_pos) == 39) { // '\''
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 109) { // 'm' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && _get_cpt(match_pos) == 39) { // '\''
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 108) { // 'l' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 108) { // 'l' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    if (!alt_matched) {
                        match_pos = alt_save;
                        matched = true;
                        if (matched && _get_cpt(match_pos) == 39) { // '\''
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched && unicode_tolower(_get_cpt(match_pos)) == 100) { // 'd' (case-insensitive)
                            match_pos++;
                        } else if (matched) { matched = false; }
                        if (matched) alt_matched = true;
                    }
                    matched = alt_matched;
                }
                
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: [^...]?\p{L}+
            {
                size_t match_pos = pos;
                bool matched = true;
                
                // Optional match
                {
                    size_t save_pos = match_pos;
                    bool save_matched = matched;
                    if (matched) {
                        uint32_t cpt_1 = _get_cpt(match_pos);
                        auto flags_cpt_1 = _get_flags(match_pos);
                        bool in_class = (cpt_1 == 13) || (cpt_1 == 10) || (flags_cpt_1.is_letter) || (flags_cpt_1.is_number);
                        if (!in_class && cpt_1 != OUT_OF_RANGE) {
                            match_pos++;
                        } else { matched = false; }
                    }
                    if (!matched) {
                        match_pos = save_pos;
                        matched = save_matched;
                    }
                }
                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_2 = _get_cpt(match_pos);
                            auto flags_cpt_2 = _get_flags(match_pos);
                            if (flags_cpt_2.is_letter) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \p{N}{1,3}
            {
                size_t match_pos = pos;
                bool matched = true;
                
                // 1 to 3 matches
                {
                    size_t count = 0;
                    while (matched && count < 3) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_3 = _get_cpt(match_pos);
                            auto flags_cpt_3 = _get_flags(match_pos);
                            if (flags_cpt_3.is_number) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count >= 1);
                            break;
                        }
                        count++;
                    }
                    if (count < 1) matched = false;
                }
                
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative:  ?[^...]+[...]*
            {
                size_t match_pos = pos;
                bool matched = true;
                
                // Optional match
                {
                    size_t save_pos = match_pos;
                    bool save_matched = matched;
                    if (matched && _get_cpt(match_pos) == 32) { // ' '
                        match_pos++;
                    } else if (matched) { matched = false; }
                    if (!matched) {
                        match_pos = save_pos;
                        matched = save_matched;
                    }
                }
                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_4 = _get_cpt(match_pos);
                            auto flags_cpt_4 = _get_flags(match_pos);
                            bool in_class = (flags_cpt_4.is_whitespace) || (flags_cpt_4.is_letter) || (flags_cpt_4.is_number);
                            if (!in_class && cpt_4 != OUT_OF_RANGE) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                // Zero or more
                while (matched) {
                    size_t save_pos = match_pos;
                    if (matched) {
                        uint32_t cpt_5 = _get_cpt(match_pos);
                        auto flags_cpt_5 = _get_flags(match_pos);
                        if ((cpt_5 == 13) || (cpt_5 == 10)) {
                            match_pos++;
                        } else { matched = false; }
                    }
                    if (!matched || match_pos == save_pos) {
                        match_pos = save_pos;
                        matched = true;
                        break;
                    }
                }
                
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \s*[...]+
            {
                size_t match_pos = pos;
                bool matched = true;
                
                // Zero or more
                while (matched) {
                    size_t save_pos = match_pos;
                    if (matched) {
                        uint32_t cpt_6 = _get_cpt(match_pos);
                        auto flags_cpt_6 = _get_flags(match_pos);
                        if (flags_cpt_6.is_whitespace) {
                            match_pos++;
                        } else { matched = false; }
                    }
                    if (!matched || match_pos == save_pos) {
                        match_pos = save_pos;
                        matched = true;
                        break;
                    }
                }
                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_7 = _get_cpt(match_pos);
                            auto flags_cpt_7 = _get_flags(match_pos);
                            if ((cpt_7 == 13) || (cpt_7 == 10)) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \s+(?!\S)
            {
                size_t match_pos = pos;
                bool matched = true;
                
                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_8 = _get_cpt(match_pos);
                            auto flags_cpt_8 = _get_flags(match_pos);
                            if (flags_cpt_8.is_whitespace) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                // Negative lookahead
                {
                    size_t save_match_pos = match_pos;
                    bool save_matched = matched;
                    if (matched) {
                        uint32_t cpt_9 = _get_cpt(match_pos);
                        auto flags_cpt_9 = _get_flags(match_pos);
                        if ((!flags_cpt_9.is_whitespace && flags_cpt_9.as_uint())) {
                            match_pos++;
                        } else { matched = false; }
                    }
                    bool lookahead_success = matched;
                    match_pos = save_match_pos;
                    matched = save_matched && !lookahead_success;
                }
                
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // Alternative: \s+
            {
                size_t match_pos = pos;
                bool matched = true;
                
                // One or more
                {
                    size_t count = 0;
                    while (matched) {
                        size_t save_pos = match_pos;
                        if (matched) {
                            uint32_t cpt_10 = _get_cpt(match_pos);
                            auto flags_cpt_10 = _get_flags(match_pos);
                            if (flags_cpt_10.is_whitespace) {
                                match_pos++;
                            } else { matched = false; }
                        }
                        if (!matched || match_pos == save_pos) {
                            match_pos = save_pos;
                            matched = (count > 0);
                            break;
                        }
                        count++;
                    }
                }
                
                if (matched && match_pos > pos) {
                    pos = match_pos;
                    _add_token(pos);
                    continue;
                }
            }
            
            // No match - consume single character
            _add_token(++pos);
        }
    }
    
    return bpe_offsets;
}
